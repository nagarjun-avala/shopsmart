
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model PrivacySettings
 * 
 */
export type PrivacySettings = $Result.DefaultSelection<Prisma.$PrivacySettingsPayload>
/**
 * Model AppearanceSettings
 * 
 */
export type AppearanceSettings = $Result.DefaultSelection<Prisma.$AppearanceSettingsPayload>
/**
 * Model AccessibilitySettings
 * 
 */
export type AccessibilitySettings = $Result.DefaultSelection<Prisma.$AccessibilitySettingsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model FamilyGroup
 * 
 */
export type FamilyGroup = $Result.DefaultSelection<Prisma.$FamilyGroupPayload>
/**
 * Model FamilyGroupMember
 * 
 */
export type FamilyGroupMember = $Result.DefaultSelection<Prisma.$FamilyGroupMemberPayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model List
 * 
 */
export type List = $Result.DefaultSelection<Prisma.$ListPayload>
/**
 * Model ListContributor
 * 
 */
export type ListContributor = $Result.DefaultSelection<Prisma.$ListContributorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CategorySharedWith
 * 
 */
export type CategorySharedWith = $Result.DefaultSelection<Prisma.$CategorySharedWithPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CategoryType: {
  SYSTEM: 'SYSTEM',
  CUSTOM: 'CUSTOM'
};

export type CategoryType = (typeof CategoryType)[keyof typeof CategoryType]


export const PriorityType: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type PriorityType = (typeof PriorityType)[keyof typeof PriorityType]


export const OtpType: {
  LOGIN: 'LOGIN',
  RESET_PASSWORD: 'RESET_PASSWORD'
};

export type OtpType = (typeof OtpType)[keyof typeof OtpType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CategoryType = $Enums.CategoryType

export const CategoryType: typeof $Enums.CategoryType

export type PriorityType = $Enums.PriorityType

export const PriorityType: typeof $Enums.PriorityType

export type OtpType = $Enums.OtpType

export const OtpType: typeof $Enums.OtpType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyGroup`: Exposes CRUD operations for the **FamilyGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyGroups
    * const familyGroups = await prisma.familyGroup.findMany()
    * ```
    */
  get familyGroup(): Prisma.FamilyGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyGroupMember`: Exposes CRUD operations for the **FamilyGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyGroupMembers
    * const familyGroupMembers = await prisma.familyGroupMember.findMany()
    * ```
    */
  get familyGroupMember(): Prisma.FamilyGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.list`: Exposes CRUD operations for the **List** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.list.findMany()
    * ```
    */
  get list(): Prisma.ListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listContributor`: Exposes CRUD operations for the **ListContributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListContributors
    * const listContributors = await prisma.listContributor.findMany()
    * ```
    */
  get listContributor(): Prisma.ListContributorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categorySharedWith`: Exposes CRUD operations for the **CategorySharedWith** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategorySharedWiths
    * const categorySharedWiths = await prisma.categorySharedWith.findMany()
    * ```
    */
  get categorySharedWith(): Prisma.CategorySharedWithDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    SecurityEvent: 'SecurityEvent',
    UserSettings: 'UserSettings',
    FamilyGroup: 'FamilyGroup',
    FamilyGroupMember: 'FamilyGroupMember',
    Invite: 'Invite',
    List: 'List',
    ListContributor: 'ListContributor',
    Category: 'Category',
    CategorySharedWith: 'CategorySharedWith',
    Item: 'Item',
    Comment: 'Comment',
    Otp: 'Otp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "securityEvent" | "userSettings" | "familyGroup" | "familyGroupMember" | "invite" | "list" | "listContributor" | "category" | "categorySharedWith" | "item" | "comment" | "otp"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SecurityEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SecurityEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserSettingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserSettingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      FamilyGroup: {
        payload: Prisma.$FamilyGroupPayload<ExtArgs>
        fields: Prisma.FamilyGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          findFirst: {
            args: Prisma.FamilyGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          findMany: {
            args: Prisma.FamilyGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>[]
          }
          create: {
            args: Prisma.FamilyGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          createMany: {
            args: Prisma.FamilyGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          update: {
            args: Prisma.FamilyGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          deleteMany: {
            args: Prisma.FamilyGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          aggregate: {
            args: Prisma.FamilyGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyGroup>
          }
          groupBy: {
            args: Prisma.FamilyGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FamilyGroupFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FamilyGroupAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FamilyGroupCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupCountAggregateOutputType> | number
          }
        }
      }
      FamilyGroupMember: {
        payload: Prisma.$FamilyGroupMemberPayload<ExtArgs>
        fields: Prisma.FamilyGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.FamilyGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          findMany: {
            args: Prisma.FamilyGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>[]
          }
          create: {
            args: Prisma.FamilyGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          createMany: {
            args: Prisma.FamilyGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          update: {
            args: Prisma.FamilyGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.FamilyGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.FamilyGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyGroupMember>
          }
          groupBy: {
            args: Prisma.FamilyGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FamilyGroupMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FamilyGroupMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FamilyGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InviteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InviteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      List: {
        payload: Prisma.$ListPayload<ExtArgs>
        fields: Prisma.ListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findFirst: {
            args: Prisma.ListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findMany: {
            args: Prisma.ListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          create: {
            args: Prisma.ListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          createMany: {
            args: Prisma.ListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          update: {
            args: Prisma.ListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          deleteMany: {
            args: Prisma.ListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          aggregate: {
            args: Prisma.ListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateList>
          }
          groupBy: {
            args: Prisma.ListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ListFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ListAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ListCountArgs<ExtArgs>
            result: $Utils.Optional<ListCountAggregateOutputType> | number
          }
        }
      }
      ListContributor: {
        payload: Prisma.$ListContributorPayload<ExtArgs>
        fields: Prisma.ListContributorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListContributorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListContributorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          findFirst: {
            args: Prisma.ListContributorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListContributorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          findMany: {
            args: Prisma.ListContributorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>[]
          }
          create: {
            args: Prisma.ListContributorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          createMany: {
            args: Prisma.ListContributorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ListContributorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          update: {
            args: Prisma.ListContributorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          deleteMany: {
            args: Prisma.ListContributorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListContributorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListContributorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListContributorPayload>
          }
          aggregate: {
            args: Prisma.ListContributorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListContributor>
          }
          groupBy: {
            args: Prisma.ListContributorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListContributorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ListContributorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ListContributorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ListContributorCountArgs<ExtArgs>
            result: $Utils.Optional<ListContributorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CategorySharedWith: {
        payload: Prisma.$CategorySharedWithPayload<ExtArgs>
        fields: Prisma.CategorySharedWithFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategorySharedWithFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategorySharedWithFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          findFirst: {
            args: Prisma.CategorySharedWithFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategorySharedWithFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          findMany: {
            args: Prisma.CategorySharedWithFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>[]
          }
          create: {
            args: Prisma.CategorySharedWithCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          createMany: {
            args: Prisma.CategorySharedWithCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategorySharedWithDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          update: {
            args: Prisma.CategorySharedWithUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          deleteMany: {
            args: Prisma.CategorySharedWithDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategorySharedWithUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategorySharedWithUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorySharedWithPayload>
          }
          aggregate: {
            args: Prisma.CategorySharedWithAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategorySharedWith>
          }
          groupBy: {
            args: Prisma.CategorySharedWithGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategorySharedWithGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategorySharedWithFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategorySharedWithAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategorySharedWithCountArgs<ExtArgs>
            result: $Utils.Optional<CategorySharedWithCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OtpFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OtpAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    securityEvent?: SecurityEventOmit
    userSettings?: UserSettingsOmit
    familyGroup?: FamilyGroupOmit
    familyGroupMember?: FamilyGroupMemberOmit
    invite?: InviteOmit
    list?: ListOmit
    listContributor?: ListContributorOmit
    category?: CategoryOmit
    categorySharedWith?: CategorySharedWithOmit
    item?: ItemOmit
    comment?: CommentOmit
    otp?: OtpOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    events: number
    createdGroups: number
    memberOfGroups: number
    contributedLists: number
    sharedCategories: number
    Otp: number
    Item: number
    List: number
    Comment: number
    createdCategories: number
    sentInvites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
    createdGroups?: boolean | UserCountOutputTypeCountCreatedGroupsArgs
    memberOfGroups?: boolean | UserCountOutputTypeCountMemberOfGroupsArgs
    contributedLists?: boolean | UserCountOutputTypeCountContributedListsArgs
    sharedCategories?: boolean | UserCountOutputTypeCountSharedCategoriesArgs
    Otp?: boolean | UserCountOutputTypeCountOtpArgs
    Item?: boolean | UserCountOutputTypeCountItemArgs
    List?: boolean | UserCountOutputTypeCountListArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    createdCategories?: boolean | UserCountOutputTypeCountCreatedCategoriesArgs
    sentInvites?: boolean | UserCountOutputTypeCountSentInvitesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberOfGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContributedListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListContributorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategorySharedWithWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }


  /**
   * Count Type FamilyGroupCountOutputType
   */

  export type FamilyGroupCountOutputType = {
    members: number
    invites: number
  }

  export type FamilyGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | FamilyGroupCountOutputTypeCountMembersArgs
    invites?: boolean | FamilyGroupCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * FamilyGroupCountOutputType without action
   */
  export type FamilyGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupCountOutputType
     */
    select?: FamilyGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyGroupCountOutputType without action
   */
  export type FamilyGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupMemberWhereInput
  }

  /**
   * FamilyGroupCountOutputType without action
   */
  export type FamilyGroupCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }


  /**
   * Count Type ListCountOutputType
   */

  export type ListCountOutputType = {
    contributors: number
    items: number
  }

  export type ListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributors?: boolean | ListCountOutputTypeCountContributorsArgs
    items?: boolean | ListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListCountOutputType
     */
    select?: ListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountContributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListContributorWhereInput
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    sharedWith: number
    categoryItems: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sharedWith?: boolean | CategoryCountOutputTypeCountSharedWithArgs
    categoryItems?: boolean | CategoryCountOutputTypeCountCategoryItemsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategorySharedWithWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCategoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    comments: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ItemCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model NotificationSettings
   */





  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    sms?: boolean
    push?: boolean
    marketing?: boolean
    productUpdates?: boolean
    securityAlerts?: boolean
  }, ExtArgs["result"]["notificationSettings"]>



  export type NotificationSettingsSelectScalar = {
    email?: boolean
    sms?: boolean
    push?: boolean
    marketing?: boolean
    productUpdates?: boolean
    securityAlerts?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "sms" | "push" | "marketing" | "productUpdates" | "securityAlerts", ExtArgs["result"]["notificationSettings"]>

  export type $NotificationSettingsPayload = {
    name: "NotificationSettings"
    objects: {}
    scalars: {
      email: boolean
      sms: boolean
      push: boolean
      marketing: boolean
      productUpdates: boolean
      securityAlerts: boolean
    }
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>





  /**
   * Fields of the NotificationSettings model
   */
  interface NotificationSettingsFieldRefs {
    readonly email: FieldRef<"NotificationSettings", 'Boolean'>
    readonly sms: FieldRef<"NotificationSettings", 'Boolean'>
    readonly push: FieldRef<"NotificationSettings", 'Boolean'>
    readonly marketing: FieldRef<"NotificationSettings", 'Boolean'>
    readonly productUpdates: FieldRef<"NotificationSettings", 'Boolean'>
    readonly securityAlerts: FieldRef<"NotificationSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
  }


  /**
   * Model PrivacySettings
   */





  export type PrivacySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileVisibility?: boolean
    searchVisibility?: boolean
    dataSharing?: boolean
    adPersonalization?: boolean
    twoFactorAuth?: boolean
  }, ExtArgs["result"]["privacySettings"]>



  export type PrivacySettingsSelectScalar = {
    profileVisibility?: boolean
    searchVisibility?: boolean
    dataSharing?: boolean
    adPersonalization?: boolean
    twoFactorAuth?: boolean
  }

  export type PrivacySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profileVisibility" | "searchVisibility" | "dataSharing" | "adPersonalization" | "twoFactorAuth", ExtArgs["result"]["privacySettings"]>

  export type $PrivacySettingsPayload = {
    name: "PrivacySettings"
    objects: {}
    scalars: {
      profileVisibility: string
      searchVisibility: boolean
      dataSharing: boolean
      adPersonalization: boolean
      twoFactorAuth: boolean
    }
    composites: {}
  }

  type PrivacySettingsGetPayload<S extends boolean | null | undefined | PrivacySettingsDefaultArgs> = $Result.GetResult<Prisma.$PrivacySettingsPayload, S>





  /**
   * Fields of the PrivacySettings model
   */
  interface PrivacySettingsFieldRefs {
    readonly profileVisibility: FieldRef<"PrivacySettings", 'String'>
    readonly searchVisibility: FieldRef<"PrivacySettings", 'Boolean'>
    readonly dataSharing: FieldRef<"PrivacySettings", 'Boolean'>
    readonly adPersonalization: FieldRef<"PrivacySettings", 'Boolean'>
    readonly twoFactorAuth: FieldRef<"PrivacySettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PrivacySettings without action
   */
  export type PrivacySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacySettings
     */
    select?: PrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacySettings
     */
    omit?: PrivacySettingsOmit<ExtArgs> | null
  }


  /**
   * Model AppearanceSettings
   */





  export type AppearanceSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    theme?: boolean
    fontSize?: boolean
    compactMode?: boolean
    animations?: boolean
    highContrastMode?: boolean
    colorBlindFriendly?: boolean
    language?: boolean
    currency?: boolean
    measuringUnits?: boolean
    dateFormat?: boolean
  }, ExtArgs["result"]["appearanceSettings"]>



  export type AppearanceSettingsSelectScalar = {
    theme?: boolean
    fontSize?: boolean
    compactMode?: boolean
    animations?: boolean
    highContrastMode?: boolean
    colorBlindFriendly?: boolean
    language?: boolean
    currency?: boolean
    measuringUnits?: boolean
    dateFormat?: boolean
  }

  export type AppearanceSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"theme" | "fontSize" | "compactMode" | "animations" | "highContrastMode" | "colorBlindFriendly" | "language" | "currency" | "measuringUnits" | "dateFormat", ExtArgs["result"]["appearanceSettings"]>

  export type $AppearanceSettingsPayload = {
    name: "AppearanceSettings"
    objects: {}
    scalars: {
      theme: string
      fontSize: string
      compactMode: boolean
      animations: boolean
      highContrastMode: boolean
      colorBlindFriendly: boolean
      language: string
      currency: string
      measuringUnits: string
      dateFormat: string
    }
    composites: {}
  }

  type AppearanceSettingsGetPayload<S extends boolean | null | undefined | AppearanceSettingsDefaultArgs> = $Result.GetResult<Prisma.$AppearanceSettingsPayload, S>





  /**
   * Fields of the AppearanceSettings model
   */
  interface AppearanceSettingsFieldRefs {
    readonly theme: FieldRef<"AppearanceSettings", 'String'>
    readonly fontSize: FieldRef<"AppearanceSettings", 'String'>
    readonly compactMode: FieldRef<"AppearanceSettings", 'Boolean'>
    readonly animations: FieldRef<"AppearanceSettings", 'Boolean'>
    readonly highContrastMode: FieldRef<"AppearanceSettings", 'Boolean'>
    readonly colorBlindFriendly: FieldRef<"AppearanceSettings", 'Boolean'>
    readonly language: FieldRef<"AppearanceSettings", 'String'>
    readonly currency: FieldRef<"AppearanceSettings", 'String'>
    readonly measuringUnits: FieldRef<"AppearanceSettings", 'String'>
    readonly dateFormat: FieldRef<"AppearanceSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AppearanceSettings without action
   */
  export type AppearanceSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppearanceSettings
     */
    select?: AppearanceSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppearanceSettings
     */
    omit?: AppearanceSettingsOmit<ExtArgs> | null
  }


  /**
   * Model AccessibilitySettings
   */





  export type AccessibilitySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    screenReader?: boolean
    textToSpeech?: boolean
    motionReduction?: boolean
  }, ExtArgs["result"]["accessibilitySettings"]>



  export type AccessibilitySettingsSelectScalar = {
    screenReader?: boolean
    textToSpeech?: boolean
    motionReduction?: boolean
  }

  export type AccessibilitySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"screenReader" | "textToSpeech" | "motionReduction", ExtArgs["result"]["accessibilitySettings"]>

  export type $AccessibilitySettingsPayload = {
    name: "AccessibilitySettings"
    objects: {}
    scalars: {
      screenReader: boolean
      textToSpeech: boolean
      motionReduction: boolean
    }
    composites: {}
  }

  type AccessibilitySettingsGetPayload<S extends boolean | null | undefined | AccessibilitySettingsDefaultArgs> = $Result.GetResult<Prisma.$AccessibilitySettingsPayload, S>





  /**
   * Fields of the AccessibilitySettings model
   */
  interface AccessibilitySettingsFieldRefs {
    readonly screenReader: FieldRef<"AccessibilitySettings", 'Boolean'>
    readonly textToSpeech: FieldRef<"AccessibilitySettings", 'Boolean'>
    readonly motionReduction: FieldRef<"AccessibilitySettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AccessibilitySettings without action
   */
  export type AccessibilitySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessibilitySettings
     */
    select?: AccessibilitySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessibilitySettings
     */
    omit?: AccessibilitySettingsOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    householdSize: number | null
  }

  export type UserSumAggregateOutputType = {
    householdSize: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    mobile: string | null
    countryCode: string | null
    isVerified: boolean | null
    isActive: boolean | null
    householdSize: number | null
    dietaryPreference: string | null
    shoppingFrequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    mobile: string | null
    countryCode: string | null
    isVerified: boolean | null
    isActive: boolean | null
    householdSize: number | null
    dietaryPreference: string | null
    shoppingFrequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    name: number
    password: number
    role: number
    mobile: number
    countryCode: number
    isVerified: number
    isActive: number
    householdSize: number
    dietaryPreference: number
    shoppingFrequency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    householdSize?: true
  }

  export type UserSumAggregateInputType = {
    householdSize?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    name?: true
    password?: true
    role?: true
    mobile?: true
    countryCode?: true
    isVerified?: true
    isActive?: true
    householdSize?: true
    dietaryPreference?: true
    shoppingFrequency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    name?: true
    password?: true
    role?: true
    mobile?: true
    countryCode?: true
    isVerified?: true
    isActive?: true
    householdSize?: true
    dietaryPreference?: true
    shoppingFrequency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    name?: true
    password?: true
    role?: true
    mobile?: true
    countryCode?: true
    isVerified?: true
    isActive?: true
    householdSize?: true
    dietaryPreference?: true
    shoppingFrequency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    name: string | null
    password: string
    role: $Enums.UserRole
    mobile: string | null
    countryCode: string | null
    isVerified: boolean
    isActive: boolean
    householdSize: number
    dietaryPreference: string
    shoppingFrequency: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    mobile?: boolean
    countryCode?: boolean
    isVerified?: boolean
    isActive?: boolean
    householdSize?: boolean
    dietaryPreference?: boolean
    shoppingFrequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    memberOfGroups?: boolean | User$memberOfGroupsArgs<ExtArgs>
    contributedLists?: boolean | User$contributedListsArgs<ExtArgs>
    sharedCategories?: boolean | User$sharedCategoriesArgs<ExtArgs>
    Otp?: boolean | User$OtpArgs<ExtArgs>
    Item?: boolean | User$ItemArgs<ExtArgs>
    List?: boolean | User$ListArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    createdCategories?: boolean | User$createdCategoriesArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    mobile?: boolean
    countryCode?: boolean
    isVerified?: boolean
    isActive?: boolean
    householdSize?: boolean
    dietaryPreference?: boolean
    shoppingFrequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "name" | "password" | "role" | "mobile" | "countryCode" | "isVerified" | "isActive" | "householdSize" | "dietaryPreference" | "shoppingFrequency" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    memberOfGroups?: boolean | User$memberOfGroupsArgs<ExtArgs>
    contributedLists?: boolean | User$contributedListsArgs<ExtArgs>
    sharedCategories?: boolean | User$sharedCategoriesArgs<ExtArgs>
    Otp?: boolean | User$OtpArgs<ExtArgs>
    Item?: boolean | User$ItemArgs<ExtArgs>
    List?: boolean | User$ListArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    createdCategories?: boolean | User$createdCategoriesArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      events: Prisma.$SecurityEventPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      createdGroups: Prisma.$FamilyGroupPayload<ExtArgs>[]
      memberOfGroups: Prisma.$FamilyGroupMemberPayload<ExtArgs>[]
      contributedLists: Prisma.$ListContributorPayload<ExtArgs>[]
      sharedCategories: Prisma.$CategorySharedWithPayload<ExtArgs>[]
      Otp: Prisma.$OtpPayload<ExtArgs>[]
      Item: Prisma.$ItemPayload<ExtArgs>[]
      List: Prisma.$ListPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      createdCategories: Prisma.$CategoryPayload<ExtArgs>[]
      sentInvites: Prisma.$InvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      name: string | null
      password: string
      role: $Enums.UserRole
      mobile: string | null
      countryCode: string | null
      isVerified: boolean
      isActive: boolean
      householdSize: number
      dietaryPreference: string
      shoppingFrequency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdGroups<T extends User$createdGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberOfGroups<T extends User$memberOfGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$memberOfGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contributedLists<T extends User$contributedListsArgs<ExtArgs> = {}>(args?: Subset<T, User$contributedListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedCategories<T extends User$sharedCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Otp<T extends User$OtpArgs<ExtArgs> = {}>(args?: Subset<T, User$OtpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Item<T extends User$ItemArgs<ExtArgs> = {}>(args?: Subset<T, User$ItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    List<T extends User$ListArgs<ExtArgs> = {}>(args?: Subset<T, User$ListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCategories<T extends User$createdCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvites<T extends User$sentInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly mobile: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly householdSize: FieldRef<"User", 'Int'>
    readonly dietaryPreference: FieldRef<"User", 'String'>
    readonly shoppingFrequency: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    cursor?: SecurityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.createdGroups
   */
  export type User$createdGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    where?: FamilyGroupWhereInput
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    cursor?: FamilyGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * User.memberOfGroups
   */
  export type User$memberOfGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    where?: FamilyGroupMemberWhereInput
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    cursor?: FamilyGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyGroupMemberScalarFieldEnum | FamilyGroupMemberScalarFieldEnum[]
  }

  /**
   * User.contributedLists
   */
  export type User$contributedListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    where?: ListContributorWhereInput
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    cursor?: ListContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListContributorScalarFieldEnum | ListContributorScalarFieldEnum[]
  }

  /**
   * User.sharedCategories
   */
  export type User$sharedCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    where?: CategorySharedWithWhereInput
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    cursor?: CategorySharedWithWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategorySharedWithScalarFieldEnum | CategorySharedWithScalarFieldEnum[]
  }

  /**
   * User.Otp
   */
  export type User$OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * User.Item
   */
  export type User$ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * User.List
   */
  export type User$ListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.createdCategories
   */
  export type User$createdCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * User.sentInvites
   */
  export type User$sentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    refreshTokenHash: string | null
    userAgent: string | null
    platform: string | null
    browser: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsed: Date | null
    revoked: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    refreshTokenHash: string | null
    userAgent: string | null
    platform: string | null
    browser: string | null
    ipAddress: string | null
    createdAt: Date | null
    lastUsed: Date | null
    revoked: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    refreshTokenHash: number
    userAgent: number
    platform: number
    browser: number
    ipAddress: number
    createdAt: number
    lastUsed: number
    revoked: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    refreshTokenHash?: true
    userAgent?: true
    platform?: true
    browser?: true
    ipAddress?: true
    createdAt?: true
    lastUsed?: true
    revoked?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    refreshTokenHash?: true
    userAgent?: true
    platform?: true
    browser?: true
    ipAddress?: true
    createdAt?: true
    lastUsed?: true
    revoked?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    refreshTokenHash?: true
    userAgent?: true
    platform?: true
    browser?: true
    ipAddress?: true
    createdAt?: true
    lastUsed?: true
    revoked?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    deviceId: string
    refreshTokenHash: string
    userAgent: string | null
    platform: string | null
    browser: string | null
    ipAddress: string | null
    createdAt: Date
    lastUsed: Date
    revoked: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    refreshTokenHash?: boolean
    userAgent?: boolean
    platform?: boolean
    browser?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsed?: boolean
    revoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    refreshTokenHash?: boolean
    userAgent?: boolean
    platform?: boolean
    browser?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    lastUsed?: boolean
    revoked?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceId" | "refreshTokenHash" | "userAgent" | "platform" | "browser" | "ipAddress" | "createdAt" | "lastUsed" | "revoked", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceId: string
      refreshTokenHash: string
      userAgent: string | null
      platform: string | null
      browser: string | null
      ipAddress: string | null
      createdAt: Date
      lastUsed: Date
      revoked: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly deviceId: FieldRef<"Session", 'String'>
    readonly refreshTokenHash: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly platform: FieldRef<"Session", 'String'>
    readonly browser: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly lastUsed: FieldRef<"Session", 'DateTime'>
    readonly revoked: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    deviceId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    deviceId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    deviceId: number
    ip: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityEventMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    deviceId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    deviceId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    deviceId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: string
    userId: string
    type: string
    deviceId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    deviceId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityEvent"]>



  export type SecurityEventSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    deviceId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "deviceId" | "ip" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["securityEvent"]>
  export type SecurityEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      deviceId: string | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * @param {SecurityEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const securityEvent = await prisma.securityEvent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SecurityEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SecurityEvent.
     * @param {SecurityEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const securityEvent = await prisma.securityEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SecurityEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'String'>
    readonly userId: FieldRef<"SecurityEvent", 'String'>
    readonly type: FieldRef<"SecurityEvent", 'String'>
    readonly deviceId: FieldRef<"SecurityEvent", 'String'>
    readonly ip: FieldRef<"SecurityEvent", 'String'>
    readonly userAgent: FieldRef<"SecurityEvent", 'String'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to update.
     */
    limit?: number
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
    /**
     * Limit how many SecurityEvents to delete.
     */
    limit?: number
  }

  /**
   * SecurityEvent findRaw
   */
  export type SecurityEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SecurityEvent aggregateRaw
   */
  export type SecurityEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityEvent
     */
    omit?: SecurityEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityEventInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notifications?: boolean | NotificationSettingsDefaultArgs<ExtArgs>
    privacy?: boolean | PrivacySettingsDefaultArgs<ExtArgs>
    appearance?: boolean | AppearanceSettingsDefaultArgs<ExtArgs>
    accessibility?: boolean | AccessibilitySettingsDefaultArgs<ExtArgs>
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>



  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "notifications" | "privacy" | "appearance" | "accessibility" | "timezone" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {
      notifications: Prisma.$NotificationSettingsPayload
      privacy: Prisma.$PrivacySettingsPayload
      appearance: Prisma.$AppearanceSettingsPayload
      accessibility: Prisma.$AccessibilitySettingsPayload
    }
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * @param {UserSettingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userSettings = await prisma.userSettings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserSettingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserSettings.
     * @param {UserSettingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userSettings = await prisma.userSettings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserSettingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly timezone: FieldRef<"UserSettings", 'String'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings findRaw
   */
  export type UserSettingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSettings aggregateRaw
   */
  export type UserSettingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model FamilyGroup
   */

  export type AggregateFamilyGroup = {
    _count: FamilyGroupCountAggregateOutputType | null
    _min: FamilyGroupMinAggregateOutputType | null
    _max: FamilyGroupMaxAggregateOutputType | null
  }

  export type FamilyGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyGroupCountAggregateOutputType = {
    id: number
    name: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamilyGroupMinAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyGroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyGroupCountAggregateInputType = {
    id?: true
    name?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamilyGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroup to aggregate.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyGroups
    **/
    _count?: true | FamilyGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyGroupMaxAggregateInputType
  }

  export type GetFamilyGroupAggregateType<T extends FamilyGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyGroup[P]>
      : GetScalarType<T[P], AggregateFamilyGroup[P]>
  }




  export type FamilyGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupWhereInput
    orderBy?: FamilyGroupOrderByWithAggregationInput | FamilyGroupOrderByWithAggregationInput[]
    by: FamilyGroupScalarFieldEnum[] | FamilyGroupScalarFieldEnum
    having?: FamilyGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyGroupCountAggregateInputType | true
    _min?: FamilyGroupMinAggregateInputType
    _max?: FamilyGroupMaxAggregateInputType
  }

  export type FamilyGroupGroupByOutputType = {
    id: string
    name: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: FamilyGroupCountAggregateOutputType | null
    _min: FamilyGroupMinAggregateOutputType | null
    _max: FamilyGroupMaxAggregateOutputType | null
  }

  type GetFamilyGroupGroupByPayload<T extends FamilyGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyGroupGroupByOutputType[P]>
        }
      >
    >


  export type FamilyGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | FamilyGroup$membersArgs<ExtArgs>
    invites?: boolean | FamilyGroup$invitesArgs<ExtArgs>
    _count?: boolean | FamilyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyGroup"]>



  export type FamilyGroupSelectScalar = {
    id?: boolean
    name?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FamilyGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["familyGroup"]>
  export type FamilyGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | FamilyGroup$membersArgs<ExtArgs>
    invites?: boolean | FamilyGroup$invitesArgs<ExtArgs>
    _count?: boolean | FamilyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FamilyGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyGroup"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$FamilyGroupMemberPayload<ExtArgs>[]
      invites: Prisma.$InvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familyGroup"]>
    composites: {}
  }

  type FamilyGroupGetPayload<S extends boolean | null | undefined | FamilyGroupDefaultArgs> = $Result.GetResult<Prisma.$FamilyGroupPayload, S>

  type FamilyGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyGroupCountAggregateInputType | true
    }

  export interface FamilyGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyGroup'], meta: { name: 'FamilyGroup' } }
    /**
     * Find zero or one FamilyGroup that matches the filter.
     * @param {FamilyGroupFindUniqueArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyGroupFindUniqueArgs>(args: SelectSubset<T, FamilyGroupFindUniqueArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyGroupFindUniqueOrThrowArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindFirstArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyGroupFindFirstArgs>(args?: SelectSubset<T, FamilyGroupFindFirstArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindFirstOrThrowArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyGroups
     * const familyGroups = await prisma.familyGroup.findMany()
     * 
     * // Get first 10 FamilyGroups
     * const familyGroups = await prisma.familyGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyGroupWithIdOnly = await prisma.familyGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyGroupFindManyArgs>(args?: SelectSubset<T, FamilyGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyGroup.
     * @param {FamilyGroupCreateArgs} args - Arguments to create a FamilyGroup.
     * @example
     * // Create one FamilyGroup
     * const FamilyGroup = await prisma.familyGroup.create({
     *   data: {
     *     // ... data to create a FamilyGroup
     *   }
     * })
     * 
     */
    create<T extends FamilyGroupCreateArgs>(args: SelectSubset<T, FamilyGroupCreateArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyGroups.
     * @param {FamilyGroupCreateManyArgs} args - Arguments to create many FamilyGroups.
     * @example
     * // Create many FamilyGroups
     * const familyGroup = await prisma.familyGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyGroupCreateManyArgs>(args?: SelectSubset<T, FamilyGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyGroup.
     * @param {FamilyGroupDeleteArgs} args - Arguments to delete one FamilyGroup.
     * @example
     * // Delete one FamilyGroup
     * const FamilyGroup = await prisma.familyGroup.delete({
     *   where: {
     *     // ... filter to delete one FamilyGroup
     *   }
     * })
     * 
     */
    delete<T extends FamilyGroupDeleteArgs>(args: SelectSubset<T, FamilyGroupDeleteArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyGroup.
     * @param {FamilyGroupUpdateArgs} args - Arguments to update one FamilyGroup.
     * @example
     * // Update one FamilyGroup
     * const familyGroup = await prisma.familyGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyGroupUpdateArgs>(args: SelectSubset<T, FamilyGroupUpdateArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyGroups.
     * @param {FamilyGroupDeleteManyArgs} args - Arguments to filter FamilyGroups to delete.
     * @example
     * // Delete a few FamilyGroups
     * const { count } = await prisma.familyGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyGroupDeleteManyArgs>(args?: SelectSubset<T, FamilyGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyGroups
     * const familyGroup = await prisma.familyGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyGroupUpdateManyArgs>(args: SelectSubset<T, FamilyGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyGroup.
     * @param {FamilyGroupUpsertArgs} args - Arguments to update or create a FamilyGroup.
     * @example
     * // Update or create a FamilyGroup
     * const familyGroup = await prisma.familyGroup.upsert({
     *   create: {
     *     // ... data to create a FamilyGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyGroup we want to update
     *   }
     * })
     */
    upsert<T extends FamilyGroupUpsertArgs>(args: SelectSubset<T, FamilyGroupUpsertArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyGroups that matches the filter.
     * @param {FamilyGroupFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyGroup = await prisma.familyGroup.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FamilyGroupFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyGroup.
     * @param {FamilyGroupAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyGroup = await prisma.familyGroup.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FamilyGroupAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FamilyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupCountArgs} args - Arguments to filter FamilyGroups to count.
     * @example
     * // Count the number of FamilyGroups
     * const count = await prisma.familyGroup.count({
     *   where: {
     *     // ... the filter for the FamilyGroups we want to count
     *   }
     * })
    **/
    count<T extends FamilyGroupCountArgs>(
      args?: Subset<T, FamilyGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyGroupAggregateArgs>(args: Subset<T, FamilyGroupAggregateArgs>): Prisma.PrismaPromise<GetFamilyGroupAggregateType<T>>

    /**
     * Group by FamilyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyGroupGroupByArgs['orderBy'] }
        : { orderBy?: FamilyGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyGroup model
   */
  readonly fields: FamilyGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends FamilyGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, FamilyGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends FamilyGroup$invitesArgs<ExtArgs> = {}>(args?: Subset<T, FamilyGroup$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyGroup model
   */
  interface FamilyGroupFieldRefs {
    readonly id: FieldRef<"FamilyGroup", 'String'>
    readonly name: FieldRef<"FamilyGroup", 'String'>
    readonly createdBy: FieldRef<"FamilyGroup", 'String'>
    readonly createdAt: FieldRef<"FamilyGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyGroup findUnique
   */
  export type FamilyGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup findUniqueOrThrow
   */
  export type FamilyGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup findFirst
   */
  export type FamilyGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroups.
     */
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup findFirstOrThrow
   */
  export type FamilyGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroups.
     */
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup findMany
   */
  export type FamilyGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroups to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup create
   */
  export type FamilyGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyGroup.
     */
    data: XOR<FamilyGroupCreateInput, FamilyGroupUncheckedCreateInput>
  }

  /**
   * FamilyGroup createMany
   */
  export type FamilyGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyGroups.
     */
    data: FamilyGroupCreateManyInput | FamilyGroupCreateManyInput[]
  }

  /**
   * FamilyGroup update
   */
  export type FamilyGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyGroup.
     */
    data: XOR<FamilyGroupUpdateInput, FamilyGroupUncheckedUpdateInput>
    /**
     * Choose, which FamilyGroup to update.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup updateMany
   */
  export type FamilyGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyGroups.
     */
    data: XOR<FamilyGroupUpdateManyMutationInput, FamilyGroupUncheckedUpdateManyInput>
    /**
     * Filter which FamilyGroups to update
     */
    where?: FamilyGroupWhereInput
    /**
     * Limit how many FamilyGroups to update.
     */
    limit?: number
  }

  /**
   * FamilyGroup upsert
   */
  export type FamilyGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyGroup to update in case it exists.
     */
    where: FamilyGroupWhereUniqueInput
    /**
     * In case the FamilyGroup found by the `where` argument doesn't exist, create a new FamilyGroup with this data.
     */
    create: XOR<FamilyGroupCreateInput, FamilyGroupUncheckedCreateInput>
    /**
     * In case the FamilyGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyGroupUpdateInput, FamilyGroupUncheckedUpdateInput>
  }

  /**
   * FamilyGroup delete
   */
  export type FamilyGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    /**
     * Filter which FamilyGroup to delete.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup deleteMany
   */
  export type FamilyGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroups to delete
     */
    where?: FamilyGroupWhereInput
    /**
     * Limit how many FamilyGroups to delete.
     */
    limit?: number
  }

  /**
   * FamilyGroup findRaw
   */
  export type FamilyGroupFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FamilyGroup aggregateRaw
   */
  export type FamilyGroupAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FamilyGroup.members
   */
  export type FamilyGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    where?: FamilyGroupMemberWhereInput
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    cursor?: FamilyGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyGroupMemberScalarFieldEnum | FamilyGroupMemberScalarFieldEnum[]
  }

  /**
   * FamilyGroup.invites
   */
  export type FamilyGroup$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * FamilyGroup without action
   */
  export type FamilyGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
  }


  /**
   * Model FamilyGroupMember
   */

  export type AggregateFamilyGroupMember = {
    _count: FamilyGroupMemberCountAggregateOutputType | null
    _min: FamilyGroupMemberMinAggregateOutputType | null
    _max: FamilyGroupMemberMaxAggregateOutputType | null
  }

  export type FamilyGroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type FamilyGroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type FamilyGroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    joinedAt: number
    _all: number
  }


  export type FamilyGroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
  }

  export type FamilyGroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
  }

  export type FamilyGroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    joinedAt?: true
    _all?: true
  }

  export type FamilyGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroupMember to aggregate.
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroupMembers to fetch.
     */
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyGroupMembers
    **/
    _count?: true | FamilyGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyGroupMemberMaxAggregateInputType
  }

  export type GetFamilyGroupMemberAggregateType<T extends FamilyGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyGroupMember[P]>
      : GetScalarType<T[P], AggregateFamilyGroupMember[P]>
  }




  export type FamilyGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupMemberWhereInput
    orderBy?: FamilyGroupMemberOrderByWithAggregationInput | FamilyGroupMemberOrderByWithAggregationInput[]
    by: FamilyGroupMemberScalarFieldEnum[] | FamilyGroupMemberScalarFieldEnum
    having?: FamilyGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyGroupMemberCountAggregateInputType | true
    _min?: FamilyGroupMemberMinAggregateInputType
    _max?: FamilyGroupMemberMaxAggregateInputType
  }

  export type FamilyGroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    joinedAt: Date
    _count: FamilyGroupMemberCountAggregateOutputType | null
    _min: FamilyGroupMemberMinAggregateOutputType | null
    _max: FamilyGroupMemberMaxAggregateOutputType | null
  }

  type GetFamilyGroupMemberGroupByPayload<T extends FamilyGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type FamilyGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
    group?: boolean | FamilyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyGroupMember"]>



  export type FamilyGroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    joinedAt?: boolean
  }

  export type FamilyGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "joinedAt", ExtArgs["result"]["familyGroupMember"]>
  export type FamilyGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | FamilyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FamilyGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyGroupMember"
    objects: {
      group: Prisma.$FamilyGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      joinedAt: Date
    }, ExtArgs["result"]["familyGroupMember"]>
    composites: {}
  }

  type FamilyGroupMemberGetPayload<S extends boolean | null | undefined | FamilyGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$FamilyGroupMemberPayload, S>

  type FamilyGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyGroupMemberCountAggregateInputType | true
    }

  export interface FamilyGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyGroupMember'], meta: { name: 'FamilyGroupMember' } }
    /**
     * Find zero or one FamilyGroupMember that matches the filter.
     * @param {FamilyGroupMemberFindUniqueArgs} args - Arguments to find a FamilyGroupMember
     * @example
     * // Get one FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyGroupMemberFindUniqueArgs>(args: SelectSubset<T, FamilyGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a FamilyGroupMember
     * @example
     * // Get one FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberFindFirstArgs} args - Arguments to find a FamilyGroupMember
     * @example
     * // Get one FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyGroupMemberFindFirstArgs>(args?: SelectSubset<T, FamilyGroupMemberFindFirstArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberFindFirstOrThrowArgs} args - Arguments to find a FamilyGroupMember
     * @example
     * // Get one FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyGroupMembers
     * const familyGroupMembers = await prisma.familyGroupMember.findMany()
     * 
     * // Get first 10 FamilyGroupMembers
     * const familyGroupMembers = await prisma.familyGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyGroupMemberWithIdOnly = await prisma.familyGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyGroupMemberFindManyArgs>(args?: SelectSubset<T, FamilyGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyGroupMember.
     * @param {FamilyGroupMemberCreateArgs} args - Arguments to create a FamilyGroupMember.
     * @example
     * // Create one FamilyGroupMember
     * const FamilyGroupMember = await prisma.familyGroupMember.create({
     *   data: {
     *     // ... data to create a FamilyGroupMember
     *   }
     * })
     * 
     */
    create<T extends FamilyGroupMemberCreateArgs>(args: SelectSubset<T, FamilyGroupMemberCreateArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyGroupMembers.
     * @param {FamilyGroupMemberCreateManyArgs} args - Arguments to create many FamilyGroupMembers.
     * @example
     * // Create many FamilyGroupMembers
     * const familyGroupMember = await prisma.familyGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyGroupMemberCreateManyArgs>(args?: SelectSubset<T, FamilyGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyGroupMember.
     * @param {FamilyGroupMemberDeleteArgs} args - Arguments to delete one FamilyGroupMember.
     * @example
     * // Delete one FamilyGroupMember
     * const FamilyGroupMember = await prisma.familyGroupMember.delete({
     *   where: {
     *     // ... filter to delete one FamilyGroupMember
     *   }
     * })
     * 
     */
    delete<T extends FamilyGroupMemberDeleteArgs>(args: SelectSubset<T, FamilyGroupMemberDeleteArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyGroupMember.
     * @param {FamilyGroupMemberUpdateArgs} args - Arguments to update one FamilyGroupMember.
     * @example
     * // Update one FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyGroupMemberUpdateArgs>(args: SelectSubset<T, FamilyGroupMemberUpdateArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyGroupMembers.
     * @param {FamilyGroupMemberDeleteManyArgs} args - Arguments to filter FamilyGroupMembers to delete.
     * @example
     * // Delete a few FamilyGroupMembers
     * const { count } = await prisma.familyGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyGroupMemberDeleteManyArgs>(args?: SelectSubset<T, FamilyGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyGroupMembers
     * const familyGroupMember = await prisma.familyGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyGroupMemberUpdateManyArgs>(args: SelectSubset<T, FamilyGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyGroupMember.
     * @param {FamilyGroupMemberUpsertArgs} args - Arguments to update or create a FamilyGroupMember.
     * @example
     * // Update or create a FamilyGroupMember
     * const familyGroupMember = await prisma.familyGroupMember.upsert({
     *   create: {
     *     // ... data to create a FamilyGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends FamilyGroupMemberUpsertArgs>(args: SelectSubset<T, FamilyGroupMemberUpsertArgs<ExtArgs>>): Prisma__FamilyGroupMemberClient<$Result.GetResult<Prisma.$FamilyGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyGroupMembers that matches the filter.
     * @param {FamilyGroupMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyGroupMember = await prisma.familyGroupMember.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FamilyGroupMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyGroupMember.
     * @param {FamilyGroupMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyGroupMember = await prisma.familyGroupMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FamilyGroupMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FamilyGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberCountArgs} args - Arguments to filter FamilyGroupMembers to count.
     * @example
     * // Count the number of FamilyGroupMembers
     * const count = await prisma.familyGroupMember.count({
     *   where: {
     *     // ... the filter for the FamilyGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends FamilyGroupMemberCountArgs>(
      args?: Subset<T, FamilyGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyGroupMemberAggregateArgs>(args: Subset<T, FamilyGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetFamilyGroupMemberAggregateType<T>>

    /**
     * Group by FamilyGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: FamilyGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyGroupMember model
   */
  readonly fields: FamilyGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends FamilyGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyGroupDefaultArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyGroupMember model
   */
  interface FamilyGroupMemberFieldRefs {
    readonly id: FieldRef<"FamilyGroupMember", 'String'>
    readonly groupId: FieldRef<"FamilyGroupMember", 'String'>
    readonly userId: FieldRef<"FamilyGroupMember", 'String'>
    readonly joinedAt: FieldRef<"FamilyGroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyGroupMember findUnique
   */
  export type FamilyGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroupMember to fetch.
     */
    where: FamilyGroupMemberWhereUniqueInput
  }

  /**
   * FamilyGroupMember findUniqueOrThrow
   */
  export type FamilyGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroupMember to fetch.
     */
    where: FamilyGroupMemberWhereUniqueInput
  }

  /**
   * FamilyGroupMember findFirst
   */
  export type FamilyGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroupMember to fetch.
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroupMembers to fetch.
     */
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroupMembers.
     */
    cursor?: FamilyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroupMembers.
     */
    distinct?: FamilyGroupMemberScalarFieldEnum | FamilyGroupMemberScalarFieldEnum[]
  }

  /**
   * FamilyGroupMember findFirstOrThrow
   */
  export type FamilyGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroupMember to fetch.
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroupMembers to fetch.
     */
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroupMembers.
     */
    cursor?: FamilyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroupMembers.
     */
    distinct?: FamilyGroupMemberScalarFieldEnum | FamilyGroupMemberScalarFieldEnum[]
  }

  /**
   * FamilyGroupMember findMany
   */
  export type FamilyGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyGroupMembers to fetch.
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroupMembers to fetch.
     */
    orderBy?: FamilyGroupMemberOrderByWithRelationInput | FamilyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyGroupMembers.
     */
    cursor?: FamilyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroupMembers.
     */
    skip?: number
    distinct?: FamilyGroupMemberScalarFieldEnum | FamilyGroupMemberScalarFieldEnum[]
  }

  /**
   * FamilyGroupMember create
   */
  export type FamilyGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyGroupMember.
     */
    data: XOR<FamilyGroupMemberCreateInput, FamilyGroupMemberUncheckedCreateInput>
  }

  /**
   * FamilyGroupMember createMany
   */
  export type FamilyGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyGroupMembers.
     */
    data: FamilyGroupMemberCreateManyInput | FamilyGroupMemberCreateManyInput[]
  }

  /**
   * FamilyGroupMember update
   */
  export type FamilyGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyGroupMember.
     */
    data: XOR<FamilyGroupMemberUpdateInput, FamilyGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which FamilyGroupMember to update.
     */
    where: FamilyGroupMemberWhereUniqueInput
  }

  /**
   * FamilyGroupMember updateMany
   */
  export type FamilyGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyGroupMembers.
     */
    data: XOR<FamilyGroupMemberUpdateManyMutationInput, FamilyGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyGroupMembers to update
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * Limit how many FamilyGroupMembers to update.
     */
    limit?: number
  }

  /**
   * FamilyGroupMember upsert
   */
  export type FamilyGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyGroupMember to update in case it exists.
     */
    where: FamilyGroupMemberWhereUniqueInput
    /**
     * In case the FamilyGroupMember found by the `where` argument doesn't exist, create a new FamilyGroupMember with this data.
     */
    create: XOR<FamilyGroupMemberCreateInput, FamilyGroupMemberUncheckedCreateInput>
    /**
     * In case the FamilyGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyGroupMemberUpdateInput, FamilyGroupMemberUncheckedUpdateInput>
  }

  /**
   * FamilyGroupMember delete
   */
  export type FamilyGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which FamilyGroupMember to delete.
     */
    where: FamilyGroupMemberWhereUniqueInput
  }

  /**
   * FamilyGroupMember deleteMany
   */
  export type FamilyGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroupMembers to delete
     */
    where?: FamilyGroupMemberWhereInput
    /**
     * Limit how many FamilyGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * FamilyGroupMember findRaw
   */
  export type FamilyGroupMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FamilyGroupMember aggregateRaw
   */
  export type FamilyGroupMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FamilyGroupMember without action
   */
  export type FamilyGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroupMember
     */
    select?: FamilyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroupMember
     */
    omit?: FamilyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteMinAggregateOutputType = {
    id: string | null
    code: string | null
    invitedBy: string | null
    email: string | null
    role: $Enums.UserRole | null
    expiresAt: Date | null
    used: boolean | null
    familyGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteMaxAggregateOutputType = {
    id: string | null
    code: string | null
    invitedBy: string | null
    email: string | null
    role: $Enums.UserRole | null
    expiresAt: Date | null
    used: boolean | null
    familyGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    code: number
    invitedBy: number
    email: number
    role: number
    expiresAt: number
    used: number
    familyGroupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InviteMinAggregateInputType = {
    id?: true
    code?: true
    invitedBy?: true
    email?: true
    role?: true
    expiresAt?: true
    used?: true
    familyGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    code?: true
    invitedBy?: true
    email?: true
    role?: true
    expiresAt?: true
    used?: true
    familyGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    code?: true
    invitedBy?: true
    email?: true
    role?: true
    expiresAt?: true
    used?: true
    familyGroupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: string
    code: string
    invitedBy: string
    email: string
    role: $Enums.UserRole
    expiresAt: Date
    used: boolean
    familyGroupId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    invitedBy?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    used?: boolean
    familyGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
    familyGroup?: boolean | Invite$familyGroupArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>



  export type InviteSelectScalar = {
    id?: boolean
    code?: boolean
    invitedBy?: boolean
    email?: boolean
    role?: boolean
    expiresAt?: boolean
    used?: boolean
    familyGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "invitedBy" | "email" | "role" | "expiresAt" | "used" | "familyGroupId" | "createdAt" | "updatedAt", ExtArgs["result"]["invite"]>
  export type InviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
    familyGroup?: boolean | Invite$familyGroupArgs<ExtArgs>
  }

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {
      invitedByUser: Prisma.$UserPayload<ExtArgs>
      familyGroup: Prisma.$FamilyGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      invitedBy: string
      email: string
      role: $Enums.UserRole
      expiresAt: Date
      used: boolean
      familyGroupId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invites that matches the filter.
     * @param {InviteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invite = await prisma.invite.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InviteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invite.
     * @param {InviteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invite = await prisma.invite.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InviteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyGroup<T extends Invite$familyGroupArgs<ExtArgs> = {}>(args?: Subset<T, Invite$familyGroupArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'String'>
    readonly code: FieldRef<"Invite", 'String'>
    readonly invitedBy: FieldRef<"Invite", 'String'>
    readonly email: FieldRef<"Invite", 'String'>
    readonly role: FieldRef<"Invite", 'UserRole'>
    readonly expiresAt: FieldRef<"Invite", 'DateTime'>
    readonly used: FieldRef<"Invite", 'Boolean'>
    readonly familyGroupId: FieldRef<"Invite", 'String'>
    readonly createdAt: FieldRef<"Invite", 'DateTime'>
    readonly updatedAt: FieldRef<"Invite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to update.
     */
    limit?: number
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to delete.
     */
    limit?: number
  }

  /**
   * Invite findRaw
   */
  export type InviteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invite aggregateRaw
   */
  export type InviteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invite.familyGroup
   */
  export type Invite$familyGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyGroup
     */
    omit?: FamilyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyGroupInclude<ExtArgs> | null
    where?: FamilyGroupWhereInput
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
  }


  /**
   * Model List
   */

  export type AggregateList = {
    _count: ListCountAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  export type ListMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdUserId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdUserId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdUserId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which List to aggregate.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lists
    **/
    _count?: true | ListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListMaxAggregateInputType
  }

  export type GetListAggregateType<T extends ListAggregateArgs> = {
        [P in keyof T & keyof AggregateList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateList[P]>
      : GetScalarType<T[P], AggregateList[P]>
  }




  export type ListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
    orderBy?: ListOrderByWithAggregationInput | ListOrderByWithAggregationInput[]
    by: ListScalarFieldEnum[] | ListScalarFieldEnum
    having?: ListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListCountAggregateInputType | true
    _min?: ListMinAggregateInputType
    _max?: ListMaxAggregateInputType
  }

  export type ListGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdUserId: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ListCountAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  type GetListGroupByPayload<T extends ListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListGroupByOutputType[P]>
            : GetScalarType<T[P], ListGroupByOutputType[P]>
        }
      >
    >


  export type ListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdUserId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdUser?: boolean | UserDefaultArgs<ExtArgs>
    contributors?: boolean | List$contributorsArgs<ExtArgs>
    items?: boolean | List$itemsArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>



  export type ListSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdUserId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdUserId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["list"]>
  export type ListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUser?: boolean | UserDefaultArgs<ExtArgs>
    contributors?: boolean | List$contributorsArgs<ExtArgs>
    items?: boolean | List$itemsArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "List"
    objects: {
      createdUser: Prisma.$UserPayload<ExtArgs>
      contributors: Prisma.$ListContributorPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdUserId: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["list"]>
    composites: {}
  }

  type ListGetPayload<S extends boolean | null | undefined | ListDefaultArgs> = $Result.GetResult<Prisma.$ListPayload, S>

  type ListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListCountAggregateInputType | true
    }

  export interface ListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['List'], meta: { name: 'List' } }
    /**
     * Find zero or one List that matches the filter.
     * @param {ListFindUniqueArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListFindUniqueArgs>(args: SelectSubset<T, ListFindUniqueArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one List that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListFindUniqueOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListFindUniqueOrThrowArgs>(args: SelectSubset<T, ListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListFindFirstArgs>(args?: SelectSubset<T, ListFindFirstArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListFindFirstOrThrowArgs>(args?: SelectSubset<T, ListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lists
     * const lists = await prisma.list.findMany()
     * 
     * // Get first 10 Lists
     * const lists = await prisma.list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listWithIdOnly = await prisma.list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListFindManyArgs>(args?: SelectSubset<T, ListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a List.
     * @param {ListCreateArgs} args - Arguments to create a List.
     * @example
     * // Create one List
     * const List = await prisma.list.create({
     *   data: {
     *     // ... data to create a List
     *   }
     * })
     * 
     */
    create<T extends ListCreateArgs>(args: SelectSubset<T, ListCreateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lists.
     * @param {ListCreateManyArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListCreateManyArgs>(args?: SelectSubset<T, ListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a List.
     * @param {ListDeleteArgs} args - Arguments to delete one List.
     * @example
     * // Delete one List
     * const List = await prisma.list.delete({
     *   where: {
     *     // ... filter to delete one List
     *   }
     * })
     * 
     */
    delete<T extends ListDeleteArgs>(args: SelectSubset<T, ListDeleteArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one List.
     * @param {ListUpdateArgs} args - Arguments to update one List.
     * @example
     * // Update one List
     * const list = await prisma.list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListUpdateArgs>(args: SelectSubset<T, ListUpdateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lists.
     * @param {ListDeleteManyArgs} args - Arguments to filter Lists to delete.
     * @example
     * // Delete a few Lists
     * const { count } = await prisma.list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListDeleteManyArgs>(args?: SelectSubset<T, ListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListUpdateManyArgs>(args: SelectSubset<T, ListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one List.
     * @param {ListUpsertArgs} args - Arguments to update or create a List.
     * @example
     * // Update or create a List
     * const list = await prisma.list.upsert({
     *   create: {
     *     // ... data to create a List
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the List we want to update
     *   }
     * })
     */
    upsert<T extends ListUpsertArgs>(args: SelectSubset<T, ListUpsertArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lists that matches the filter.
     * @param {ListFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const list = await prisma.list.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ListFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a List.
     * @param {ListAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const list = await prisma.list.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ListAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListCountArgs} args - Arguments to filter Lists to count.
     * @example
     * // Count the number of Lists
     * const count = await prisma.list.count({
     *   where: {
     *     // ... the filter for the Lists we want to count
     *   }
     * })
    **/
    count<T extends ListCountArgs>(
      args?: Subset<T, ListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListAggregateArgs>(args: Subset<T, ListAggregateArgs>): Prisma.PrismaPromise<GetListAggregateType<T>>

    /**
     * Group by List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListGroupByArgs['orderBy'] }
        : { orderBy?: ListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the List model
   */
  readonly fields: ListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for List.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contributors<T extends List$contributorsArgs<ExtArgs> = {}>(args?: Subset<T, List$contributorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends List$itemsArgs<ExtArgs> = {}>(args?: Subset<T, List$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the List model
   */
  interface ListFieldRefs {
    readonly id: FieldRef<"List", 'String'>
    readonly name: FieldRef<"List", 'String'>
    readonly slug: FieldRef<"List", 'String'>
    readonly description: FieldRef<"List", 'String'>
    readonly createdUserId: FieldRef<"List", 'String'>
    readonly status: FieldRef<"List", 'String'>
    readonly createdAt: FieldRef<"List", 'DateTime'>
    readonly updatedAt: FieldRef<"List", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * List findUnique
   */
  export type ListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findUniqueOrThrow
   */
  export type ListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findFirst
   */
  export type ListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findFirstOrThrow
   */
  export type ListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findMany
   */
  export type ListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which Lists to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List create
   */
  export type ListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to create a List.
     */
    data: XOR<ListCreateInput, ListUncheckedCreateInput>
  }

  /**
   * List createMany
   */
  export type ListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
  }

  /**
   * List update
   */
  export type ListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to update a List.
     */
    data: XOR<ListUpdateInput, ListUncheckedUpdateInput>
    /**
     * Choose, which List to update.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List updateMany
   */
  export type ListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
  }

  /**
   * List upsert
   */
  export type ListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The filter to search for the List to update in case it exists.
     */
    where: ListWhereUniqueInput
    /**
     * In case the List found by the `where` argument doesn't exist, create a new List with this data.
     */
    create: XOR<ListCreateInput, ListUncheckedCreateInput>
    /**
     * In case the List was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListUpdateInput, ListUncheckedUpdateInput>
  }

  /**
   * List delete
   */
  export type ListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter which List to delete.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List deleteMany
   */
  export type ListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lists to delete
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to delete.
     */
    limit?: number
  }

  /**
   * List findRaw
   */
  export type ListFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * List aggregateRaw
   */
  export type ListAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * List.contributors
   */
  export type List$contributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    where?: ListContributorWhereInput
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    cursor?: ListContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListContributorScalarFieldEnum | ListContributorScalarFieldEnum[]
  }

  /**
   * List.items
   */
  export type List$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * List without action
   */
  export type ListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
  }


  /**
   * Model ListContributor
   */

  export type AggregateListContributor = {
    _count: ListContributorCountAggregateOutputType | null
    _min: ListContributorMinAggregateOutputType | null
    _max: ListContributorMaxAggregateOutputType | null
  }

  export type ListContributorMinAggregateOutputType = {
    id: string | null
    listId: string | null
    userId: string | null
  }

  export type ListContributorMaxAggregateOutputType = {
    id: string | null
    listId: string | null
    userId: string | null
  }

  export type ListContributorCountAggregateOutputType = {
    id: number
    listId: number
    userId: number
    _all: number
  }


  export type ListContributorMinAggregateInputType = {
    id?: true
    listId?: true
    userId?: true
  }

  export type ListContributorMaxAggregateInputType = {
    id?: true
    listId?: true
    userId?: true
  }

  export type ListContributorCountAggregateInputType = {
    id?: true
    listId?: true
    userId?: true
    _all?: true
  }

  export type ListContributorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListContributor to aggregate.
     */
    where?: ListContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListContributors to fetch.
     */
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListContributors
    **/
    _count?: true | ListContributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListContributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListContributorMaxAggregateInputType
  }

  export type GetListContributorAggregateType<T extends ListContributorAggregateArgs> = {
        [P in keyof T & keyof AggregateListContributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListContributor[P]>
      : GetScalarType<T[P], AggregateListContributor[P]>
  }




  export type ListContributorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListContributorWhereInput
    orderBy?: ListContributorOrderByWithAggregationInput | ListContributorOrderByWithAggregationInput[]
    by: ListContributorScalarFieldEnum[] | ListContributorScalarFieldEnum
    having?: ListContributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListContributorCountAggregateInputType | true
    _min?: ListContributorMinAggregateInputType
    _max?: ListContributorMaxAggregateInputType
  }

  export type ListContributorGroupByOutputType = {
    id: string
    listId: string
    userId: string
    _count: ListContributorCountAggregateOutputType | null
    _min: ListContributorMinAggregateOutputType | null
    _max: ListContributorMaxAggregateOutputType | null
  }

  type GetListContributorGroupByPayload<T extends ListContributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListContributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListContributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListContributorGroupByOutputType[P]>
            : GetScalarType<T[P], ListContributorGroupByOutputType[P]>
        }
      >
    >


  export type ListContributorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    userId?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listContributor"]>



  export type ListContributorSelectScalar = {
    id?: boolean
    listId?: boolean
    userId?: boolean
  }

  export type ListContributorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listId" | "userId", ExtArgs["result"]["listContributor"]>
  export type ListContributorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ListContributorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListContributor"
    objects: {
      list: Prisma.$ListPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listId: string
      userId: string
    }, ExtArgs["result"]["listContributor"]>
    composites: {}
  }

  type ListContributorGetPayload<S extends boolean | null | undefined | ListContributorDefaultArgs> = $Result.GetResult<Prisma.$ListContributorPayload, S>

  type ListContributorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListContributorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListContributorCountAggregateInputType | true
    }

  export interface ListContributorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListContributor'], meta: { name: 'ListContributor' } }
    /**
     * Find zero or one ListContributor that matches the filter.
     * @param {ListContributorFindUniqueArgs} args - Arguments to find a ListContributor
     * @example
     * // Get one ListContributor
     * const listContributor = await prisma.listContributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListContributorFindUniqueArgs>(args: SelectSubset<T, ListContributorFindUniqueArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListContributor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListContributorFindUniqueOrThrowArgs} args - Arguments to find a ListContributor
     * @example
     * // Get one ListContributor
     * const listContributor = await prisma.listContributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListContributorFindUniqueOrThrowArgs>(args: SelectSubset<T, ListContributorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListContributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorFindFirstArgs} args - Arguments to find a ListContributor
     * @example
     * // Get one ListContributor
     * const listContributor = await prisma.listContributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListContributorFindFirstArgs>(args?: SelectSubset<T, ListContributorFindFirstArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListContributor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorFindFirstOrThrowArgs} args - Arguments to find a ListContributor
     * @example
     * // Get one ListContributor
     * const listContributor = await prisma.listContributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListContributorFindFirstOrThrowArgs>(args?: SelectSubset<T, ListContributorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListContributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListContributors
     * const listContributors = await prisma.listContributor.findMany()
     * 
     * // Get first 10 ListContributors
     * const listContributors = await prisma.listContributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listContributorWithIdOnly = await prisma.listContributor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListContributorFindManyArgs>(args?: SelectSubset<T, ListContributorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListContributor.
     * @param {ListContributorCreateArgs} args - Arguments to create a ListContributor.
     * @example
     * // Create one ListContributor
     * const ListContributor = await prisma.listContributor.create({
     *   data: {
     *     // ... data to create a ListContributor
     *   }
     * })
     * 
     */
    create<T extends ListContributorCreateArgs>(args: SelectSubset<T, ListContributorCreateArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListContributors.
     * @param {ListContributorCreateManyArgs} args - Arguments to create many ListContributors.
     * @example
     * // Create many ListContributors
     * const listContributor = await prisma.listContributor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListContributorCreateManyArgs>(args?: SelectSubset<T, ListContributorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ListContributor.
     * @param {ListContributorDeleteArgs} args - Arguments to delete one ListContributor.
     * @example
     * // Delete one ListContributor
     * const ListContributor = await prisma.listContributor.delete({
     *   where: {
     *     // ... filter to delete one ListContributor
     *   }
     * })
     * 
     */
    delete<T extends ListContributorDeleteArgs>(args: SelectSubset<T, ListContributorDeleteArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListContributor.
     * @param {ListContributorUpdateArgs} args - Arguments to update one ListContributor.
     * @example
     * // Update one ListContributor
     * const listContributor = await prisma.listContributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListContributorUpdateArgs>(args: SelectSubset<T, ListContributorUpdateArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListContributors.
     * @param {ListContributorDeleteManyArgs} args - Arguments to filter ListContributors to delete.
     * @example
     * // Delete a few ListContributors
     * const { count } = await prisma.listContributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListContributorDeleteManyArgs>(args?: SelectSubset<T, ListContributorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListContributors
     * const listContributor = await prisma.listContributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListContributorUpdateManyArgs>(args: SelectSubset<T, ListContributorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListContributor.
     * @param {ListContributorUpsertArgs} args - Arguments to update or create a ListContributor.
     * @example
     * // Update or create a ListContributor
     * const listContributor = await prisma.listContributor.upsert({
     *   create: {
     *     // ... data to create a ListContributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListContributor we want to update
     *   }
     * })
     */
    upsert<T extends ListContributorUpsertArgs>(args: SelectSubset<T, ListContributorUpsertArgs<ExtArgs>>): Prisma__ListContributorClient<$Result.GetResult<Prisma.$ListContributorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListContributors that matches the filter.
     * @param {ListContributorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const listContributor = await prisma.listContributor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ListContributorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ListContributor.
     * @param {ListContributorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const listContributor = await prisma.listContributor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ListContributorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ListContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorCountArgs} args - Arguments to filter ListContributors to count.
     * @example
     * // Count the number of ListContributors
     * const count = await prisma.listContributor.count({
     *   where: {
     *     // ... the filter for the ListContributors we want to count
     *   }
     * })
    **/
    count<T extends ListContributorCountArgs>(
      args?: Subset<T, ListContributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListContributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListContributorAggregateArgs>(args: Subset<T, ListContributorAggregateArgs>): Prisma.PrismaPromise<GetListContributorAggregateType<T>>

    /**
     * Group by ListContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListContributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListContributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListContributorGroupByArgs['orderBy'] }
        : { orderBy?: ListContributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListContributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListContributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListContributor model
   */
  readonly fields: ListContributorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListContributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListContributorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends ListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListDefaultArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListContributor model
   */
  interface ListContributorFieldRefs {
    readonly id: FieldRef<"ListContributor", 'String'>
    readonly listId: FieldRef<"ListContributor", 'String'>
    readonly userId: FieldRef<"ListContributor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListContributor findUnique
   */
  export type ListContributorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter, which ListContributor to fetch.
     */
    where: ListContributorWhereUniqueInput
  }

  /**
   * ListContributor findUniqueOrThrow
   */
  export type ListContributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter, which ListContributor to fetch.
     */
    where: ListContributorWhereUniqueInput
  }

  /**
   * ListContributor findFirst
   */
  export type ListContributorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter, which ListContributor to fetch.
     */
    where?: ListContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListContributors to fetch.
     */
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListContributors.
     */
    cursor?: ListContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListContributors.
     */
    distinct?: ListContributorScalarFieldEnum | ListContributorScalarFieldEnum[]
  }

  /**
   * ListContributor findFirstOrThrow
   */
  export type ListContributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter, which ListContributor to fetch.
     */
    where?: ListContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListContributors to fetch.
     */
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListContributors.
     */
    cursor?: ListContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListContributors.
     */
    distinct?: ListContributorScalarFieldEnum | ListContributorScalarFieldEnum[]
  }

  /**
   * ListContributor findMany
   */
  export type ListContributorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter, which ListContributors to fetch.
     */
    where?: ListContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListContributors to fetch.
     */
    orderBy?: ListContributorOrderByWithRelationInput | ListContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListContributors.
     */
    cursor?: ListContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListContributors.
     */
    skip?: number
    distinct?: ListContributorScalarFieldEnum | ListContributorScalarFieldEnum[]
  }

  /**
   * ListContributor create
   */
  export type ListContributorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * The data needed to create a ListContributor.
     */
    data: XOR<ListContributorCreateInput, ListContributorUncheckedCreateInput>
  }

  /**
   * ListContributor createMany
   */
  export type ListContributorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListContributors.
     */
    data: ListContributorCreateManyInput | ListContributorCreateManyInput[]
  }

  /**
   * ListContributor update
   */
  export type ListContributorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * The data needed to update a ListContributor.
     */
    data: XOR<ListContributorUpdateInput, ListContributorUncheckedUpdateInput>
    /**
     * Choose, which ListContributor to update.
     */
    where: ListContributorWhereUniqueInput
  }

  /**
   * ListContributor updateMany
   */
  export type ListContributorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListContributors.
     */
    data: XOR<ListContributorUpdateManyMutationInput, ListContributorUncheckedUpdateManyInput>
    /**
     * Filter which ListContributors to update
     */
    where?: ListContributorWhereInput
    /**
     * Limit how many ListContributors to update.
     */
    limit?: number
  }

  /**
   * ListContributor upsert
   */
  export type ListContributorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * The filter to search for the ListContributor to update in case it exists.
     */
    where: ListContributorWhereUniqueInput
    /**
     * In case the ListContributor found by the `where` argument doesn't exist, create a new ListContributor with this data.
     */
    create: XOR<ListContributorCreateInput, ListContributorUncheckedCreateInput>
    /**
     * In case the ListContributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListContributorUpdateInput, ListContributorUncheckedUpdateInput>
  }

  /**
   * ListContributor delete
   */
  export type ListContributorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
    /**
     * Filter which ListContributor to delete.
     */
    where: ListContributorWhereUniqueInput
  }

  /**
   * ListContributor deleteMany
   */
  export type ListContributorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListContributors to delete
     */
    where?: ListContributorWhereInput
    /**
     * Limit how many ListContributors to delete.
     */
    limit?: number
  }

  /**
   * ListContributor findRaw
   */
  export type ListContributorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ListContributor aggregateRaw
   */
  export type ListContributorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ListContributor without action
   */
  export type ListContributorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListContributor
     */
    select?: ListContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListContributor
     */
    omit?: ListContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListContributorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    color: string | null
    type: $Enums.CategoryType | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    color: string | null
    type: $Enums.CategoryType | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    icon: number
    color: number
    type: number
    isActive: number
    createdBy: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    isActive?: true
    createdBy?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    icon: string | null
    color: string | null
    type: $Enums.CategoryType
    isActive: boolean
    createdBy: string | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    isActive?: boolean
    createdBy?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUser?: boolean | Category$createdByUserArgs<ExtArgs>
    sharedWith?: boolean | Category$sharedWithArgs<ExtArgs>
    categoryItems?: boolean | Category$categoryItemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    isActive?: boolean
    createdBy?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "icon" | "color" | "type" | "isActive" | "createdBy" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Category$createdByUserArgs<ExtArgs>
    sharedWith?: boolean | Category$sharedWithArgs<ExtArgs>
    categoryItems?: boolean | Category$categoryItemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      sharedWith: Prisma.$CategorySharedWithPayload<ExtArgs>[]
      categoryItems: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      icon: string | null
      color: string | null
      type: $Enums.CategoryType
      isActive: boolean
      createdBy: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends Category$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, Category$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sharedWith<T extends Category$sharedWithArgs<ExtArgs> = {}>(args?: Subset<T, Category$sharedWithArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoryItems<T extends Category$categoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Category$categoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'CategoryType'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdBy: FieldRef<"Category", 'String'>
    readonly meta: FieldRef<"Category", 'Json'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category.createdByUser
   */
  export type Category$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Category.sharedWith
   */
  export type Category$sharedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    where?: CategorySharedWithWhereInput
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    cursor?: CategorySharedWithWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategorySharedWithScalarFieldEnum | CategorySharedWithScalarFieldEnum[]
  }

  /**
   * Category.categoryItems
   */
  export type Category$categoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model CategorySharedWith
   */

  export type AggregateCategorySharedWith = {
    _count: CategorySharedWithCountAggregateOutputType | null
    _min: CategorySharedWithMinAggregateOutputType | null
    _max: CategorySharedWithMaxAggregateOutputType | null
  }

  export type CategorySharedWithMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    userId: string | null
  }

  export type CategorySharedWithMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    userId: string | null
  }

  export type CategorySharedWithCountAggregateOutputType = {
    id: number
    categoryId: number
    userId: number
    _all: number
  }


  export type CategorySharedWithMinAggregateInputType = {
    id?: true
    categoryId?: true
    userId?: true
  }

  export type CategorySharedWithMaxAggregateInputType = {
    id?: true
    categoryId?: true
    userId?: true
  }

  export type CategorySharedWithCountAggregateInputType = {
    id?: true
    categoryId?: true
    userId?: true
    _all?: true
  }

  export type CategorySharedWithAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategorySharedWith to aggregate.
     */
    where?: CategorySharedWithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorySharedWiths to fetch.
     */
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategorySharedWithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorySharedWiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorySharedWiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategorySharedWiths
    **/
    _count?: true | CategorySharedWithCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategorySharedWithMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategorySharedWithMaxAggregateInputType
  }

  export type GetCategorySharedWithAggregateType<T extends CategorySharedWithAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorySharedWith]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorySharedWith[P]>
      : GetScalarType<T[P], AggregateCategorySharedWith[P]>
  }




  export type CategorySharedWithGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategorySharedWithWhereInput
    orderBy?: CategorySharedWithOrderByWithAggregationInput | CategorySharedWithOrderByWithAggregationInput[]
    by: CategorySharedWithScalarFieldEnum[] | CategorySharedWithScalarFieldEnum
    having?: CategorySharedWithScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategorySharedWithCountAggregateInputType | true
    _min?: CategorySharedWithMinAggregateInputType
    _max?: CategorySharedWithMaxAggregateInputType
  }

  export type CategorySharedWithGroupByOutputType = {
    id: string
    categoryId: string
    userId: string
    _count: CategorySharedWithCountAggregateOutputType | null
    _min: CategorySharedWithMinAggregateOutputType | null
    _max: CategorySharedWithMaxAggregateOutputType | null
  }

  type GetCategorySharedWithGroupByPayload<T extends CategorySharedWithGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategorySharedWithGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategorySharedWithGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategorySharedWithGroupByOutputType[P]>
            : GetScalarType<T[P], CategorySharedWithGroupByOutputType[P]>
        }
      >
    >


  export type CategorySharedWithSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    userId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categorySharedWith"]>



  export type CategorySharedWithSelectScalar = {
    id?: boolean
    categoryId?: boolean
    userId?: boolean
  }

  export type CategorySharedWithOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "userId", ExtArgs["result"]["categorySharedWith"]>
  export type CategorySharedWithInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CategorySharedWithPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategorySharedWith"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      userId: string
    }, ExtArgs["result"]["categorySharedWith"]>
    composites: {}
  }

  type CategorySharedWithGetPayload<S extends boolean | null | undefined | CategorySharedWithDefaultArgs> = $Result.GetResult<Prisma.$CategorySharedWithPayload, S>

  type CategorySharedWithCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategorySharedWithFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategorySharedWithCountAggregateInputType | true
    }

  export interface CategorySharedWithDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategorySharedWith'], meta: { name: 'CategorySharedWith' } }
    /**
     * Find zero or one CategorySharedWith that matches the filter.
     * @param {CategorySharedWithFindUniqueArgs} args - Arguments to find a CategorySharedWith
     * @example
     * // Get one CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategorySharedWithFindUniqueArgs>(args: SelectSubset<T, CategorySharedWithFindUniqueArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategorySharedWith that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategorySharedWithFindUniqueOrThrowArgs} args - Arguments to find a CategorySharedWith
     * @example
     * // Get one CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategorySharedWithFindUniqueOrThrowArgs>(args: SelectSubset<T, CategorySharedWithFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategorySharedWith that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithFindFirstArgs} args - Arguments to find a CategorySharedWith
     * @example
     * // Get one CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategorySharedWithFindFirstArgs>(args?: SelectSubset<T, CategorySharedWithFindFirstArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategorySharedWith that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithFindFirstOrThrowArgs} args - Arguments to find a CategorySharedWith
     * @example
     * // Get one CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategorySharedWithFindFirstOrThrowArgs>(args?: SelectSubset<T, CategorySharedWithFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategorySharedWiths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategorySharedWiths
     * const categorySharedWiths = await prisma.categorySharedWith.findMany()
     * 
     * // Get first 10 CategorySharedWiths
     * const categorySharedWiths = await prisma.categorySharedWith.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categorySharedWithWithIdOnly = await prisma.categorySharedWith.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategorySharedWithFindManyArgs>(args?: SelectSubset<T, CategorySharedWithFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategorySharedWith.
     * @param {CategorySharedWithCreateArgs} args - Arguments to create a CategorySharedWith.
     * @example
     * // Create one CategorySharedWith
     * const CategorySharedWith = await prisma.categorySharedWith.create({
     *   data: {
     *     // ... data to create a CategorySharedWith
     *   }
     * })
     * 
     */
    create<T extends CategorySharedWithCreateArgs>(args: SelectSubset<T, CategorySharedWithCreateArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategorySharedWiths.
     * @param {CategorySharedWithCreateManyArgs} args - Arguments to create many CategorySharedWiths.
     * @example
     * // Create many CategorySharedWiths
     * const categorySharedWith = await prisma.categorySharedWith.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategorySharedWithCreateManyArgs>(args?: SelectSubset<T, CategorySharedWithCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategorySharedWith.
     * @param {CategorySharedWithDeleteArgs} args - Arguments to delete one CategorySharedWith.
     * @example
     * // Delete one CategorySharedWith
     * const CategorySharedWith = await prisma.categorySharedWith.delete({
     *   where: {
     *     // ... filter to delete one CategorySharedWith
     *   }
     * })
     * 
     */
    delete<T extends CategorySharedWithDeleteArgs>(args: SelectSubset<T, CategorySharedWithDeleteArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategorySharedWith.
     * @param {CategorySharedWithUpdateArgs} args - Arguments to update one CategorySharedWith.
     * @example
     * // Update one CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategorySharedWithUpdateArgs>(args: SelectSubset<T, CategorySharedWithUpdateArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategorySharedWiths.
     * @param {CategorySharedWithDeleteManyArgs} args - Arguments to filter CategorySharedWiths to delete.
     * @example
     * // Delete a few CategorySharedWiths
     * const { count } = await prisma.categorySharedWith.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategorySharedWithDeleteManyArgs>(args?: SelectSubset<T, CategorySharedWithDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategorySharedWiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategorySharedWiths
     * const categorySharedWith = await prisma.categorySharedWith.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategorySharedWithUpdateManyArgs>(args: SelectSubset<T, CategorySharedWithUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategorySharedWith.
     * @param {CategorySharedWithUpsertArgs} args - Arguments to update or create a CategorySharedWith.
     * @example
     * // Update or create a CategorySharedWith
     * const categorySharedWith = await prisma.categorySharedWith.upsert({
     *   create: {
     *     // ... data to create a CategorySharedWith
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategorySharedWith we want to update
     *   }
     * })
     */
    upsert<T extends CategorySharedWithUpsertArgs>(args: SelectSubset<T, CategorySharedWithUpsertArgs<ExtArgs>>): Prisma__CategorySharedWithClient<$Result.GetResult<Prisma.$CategorySharedWithPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategorySharedWiths that matches the filter.
     * @param {CategorySharedWithFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const categorySharedWith = await prisma.categorySharedWith.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategorySharedWithFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CategorySharedWith.
     * @param {CategorySharedWithAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const categorySharedWith = await prisma.categorySharedWith.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategorySharedWithAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CategorySharedWiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithCountArgs} args - Arguments to filter CategorySharedWiths to count.
     * @example
     * // Count the number of CategorySharedWiths
     * const count = await prisma.categorySharedWith.count({
     *   where: {
     *     // ... the filter for the CategorySharedWiths we want to count
     *   }
     * })
    **/
    count<T extends CategorySharedWithCountArgs>(
      args?: Subset<T, CategorySharedWithCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategorySharedWithCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategorySharedWith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategorySharedWithAggregateArgs>(args: Subset<T, CategorySharedWithAggregateArgs>): Prisma.PrismaPromise<GetCategorySharedWithAggregateType<T>>

    /**
     * Group by CategorySharedWith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorySharedWithGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategorySharedWithGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategorySharedWithGroupByArgs['orderBy'] }
        : { orderBy?: CategorySharedWithGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategorySharedWithGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategorySharedWithGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategorySharedWith model
   */
  readonly fields: CategorySharedWithFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategorySharedWith.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategorySharedWithClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategorySharedWith model
   */
  interface CategorySharedWithFieldRefs {
    readonly id: FieldRef<"CategorySharedWith", 'String'>
    readonly categoryId: FieldRef<"CategorySharedWith", 'String'>
    readonly userId: FieldRef<"CategorySharedWith", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CategorySharedWith findUnique
   */
  export type CategorySharedWithFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter, which CategorySharedWith to fetch.
     */
    where: CategorySharedWithWhereUniqueInput
  }

  /**
   * CategorySharedWith findUniqueOrThrow
   */
  export type CategorySharedWithFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter, which CategorySharedWith to fetch.
     */
    where: CategorySharedWithWhereUniqueInput
  }

  /**
   * CategorySharedWith findFirst
   */
  export type CategorySharedWithFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter, which CategorySharedWith to fetch.
     */
    where?: CategorySharedWithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorySharedWiths to fetch.
     */
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategorySharedWiths.
     */
    cursor?: CategorySharedWithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorySharedWiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorySharedWiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategorySharedWiths.
     */
    distinct?: CategorySharedWithScalarFieldEnum | CategorySharedWithScalarFieldEnum[]
  }

  /**
   * CategorySharedWith findFirstOrThrow
   */
  export type CategorySharedWithFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter, which CategorySharedWith to fetch.
     */
    where?: CategorySharedWithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorySharedWiths to fetch.
     */
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategorySharedWiths.
     */
    cursor?: CategorySharedWithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorySharedWiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorySharedWiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategorySharedWiths.
     */
    distinct?: CategorySharedWithScalarFieldEnum | CategorySharedWithScalarFieldEnum[]
  }

  /**
   * CategorySharedWith findMany
   */
  export type CategorySharedWithFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter, which CategorySharedWiths to fetch.
     */
    where?: CategorySharedWithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorySharedWiths to fetch.
     */
    orderBy?: CategorySharedWithOrderByWithRelationInput | CategorySharedWithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategorySharedWiths.
     */
    cursor?: CategorySharedWithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorySharedWiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorySharedWiths.
     */
    skip?: number
    distinct?: CategorySharedWithScalarFieldEnum | CategorySharedWithScalarFieldEnum[]
  }

  /**
   * CategorySharedWith create
   */
  export type CategorySharedWithCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * The data needed to create a CategorySharedWith.
     */
    data: XOR<CategorySharedWithCreateInput, CategorySharedWithUncheckedCreateInput>
  }

  /**
   * CategorySharedWith createMany
   */
  export type CategorySharedWithCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategorySharedWiths.
     */
    data: CategorySharedWithCreateManyInput | CategorySharedWithCreateManyInput[]
  }

  /**
   * CategorySharedWith update
   */
  export type CategorySharedWithUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * The data needed to update a CategorySharedWith.
     */
    data: XOR<CategorySharedWithUpdateInput, CategorySharedWithUncheckedUpdateInput>
    /**
     * Choose, which CategorySharedWith to update.
     */
    where: CategorySharedWithWhereUniqueInput
  }

  /**
   * CategorySharedWith updateMany
   */
  export type CategorySharedWithUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategorySharedWiths.
     */
    data: XOR<CategorySharedWithUpdateManyMutationInput, CategorySharedWithUncheckedUpdateManyInput>
    /**
     * Filter which CategorySharedWiths to update
     */
    where?: CategorySharedWithWhereInput
    /**
     * Limit how many CategorySharedWiths to update.
     */
    limit?: number
  }

  /**
   * CategorySharedWith upsert
   */
  export type CategorySharedWithUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * The filter to search for the CategorySharedWith to update in case it exists.
     */
    where: CategorySharedWithWhereUniqueInput
    /**
     * In case the CategorySharedWith found by the `where` argument doesn't exist, create a new CategorySharedWith with this data.
     */
    create: XOR<CategorySharedWithCreateInput, CategorySharedWithUncheckedCreateInput>
    /**
     * In case the CategorySharedWith was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategorySharedWithUpdateInput, CategorySharedWithUncheckedUpdateInput>
  }

  /**
   * CategorySharedWith delete
   */
  export type CategorySharedWithDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
    /**
     * Filter which CategorySharedWith to delete.
     */
    where: CategorySharedWithWhereUniqueInput
  }

  /**
   * CategorySharedWith deleteMany
   */
  export type CategorySharedWithDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategorySharedWiths to delete
     */
    where?: CategorySharedWithWhereInput
    /**
     * Limit how many CategorySharedWiths to delete.
     */
    limit?: number
  }

  /**
   * CategorySharedWith findRaw
   */
  export type CategorySharedWithFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CategorySharedWith aggregateRaw
   */
  export type CategorySharedWithAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CategorySharedWith without action
   */
  export type CategorySharedWithDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorySharedWith
     */
    select?: CategorySharedWithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategorySharedWith
     */
    omit?: CategorySharedWithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorySharedWithInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    quantity: number | null
    estimatedPrice: number | null
  }

  export type ItemSumAggregateOutputType = {
    quantity: number | null
    estimatedPrice: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unit: string | null
    priority: $Enums.PriorityType | null
    completed: boolean | null
    note: string | null
    listId: string | null
    categoryId: string | null
    brand: string | null
    estimatedPrice: number | null
    addedUserId: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unit: string | null
    priority: $Enums.PriorityType | null
    completed: boolean | null
    note: string | null
    listId: string | null
    categoryId: string | null
    brand: string | null
    estimatedPrice: number | null
    addedUserId: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    quantity: number
    unit: number
    priority: number
    completed: number
    note: number
    listId: number
    categoryId: number
    brand: number
    estimatedPrice: number
    addedUserId: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    quantity?: true
    estimatedPrice?: true
  }

  export type ItemSumAggregateInputType = {
    quantity?: true
    estimatedPrice?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    priority?: true
    completed?: true
    note?: true
    listId?: true
    categoryId?: true
    brand?: true
    estimatedPrice?: true
    addedUserId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    priority?: true
    completed?: true
    note?: true
    listId?: true
    categoryId?: true
    brand?: true
    estimatedPrice?: true
    addedUserId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    unit?: true
    priority?: true
    completed?: true
    note?: true
    listId?: true
    categoryId?: true
    brand?: true
    estimatedPrice?: true
    addedUserId?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    quantity: number
    unit: string | null
    priority: $Enums.PriorityType
    completed: boolean
    note: string | null
    listId: string | null
    categoryId: string
    brand: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    priority?: boolean
    completed?: boolean
    note?: boolean
    listId?: boolean
    categoryId?: boolean
    brand?: boolean
    estimatedPrice?: boolean
    addedUserId?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    list?: boolean | Item$listArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Item$commentsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>



  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    priority?: boolean
    completed?: boolean
    note?: boolean
    listId?: boolean
    categoryId?: boolean
    brand?: boolean
    estimatedPrice?: boolean
    addedUserId?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "quantity" | "unit" | "priority" | "completed" | "note" | "listId" | "categoryId" | "brand" | "estimatedPrice" | "addedUserId" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | Item$listArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Item$commentsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      list: Prisma.$ListPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs>
      addedBy: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      quantity: number
      unit: string | null
      priority: $Enums.PriorityType
      completed: boolean
      note: string | null
      listId: string | null
      categoryId: string
      brand: string | null
      estimatedPrice: number
      addedUserId: string
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * @param {ItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const item = await prisma.item.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Item.
     * @param {ItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const item = await prisma.item.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends Item$listArgs<ExtArgs> = {}>(args?: Subset<T, Item$listArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Item$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Item$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly quantity: FieldRef<"Item", 'Int'>
    readonly unit: FieldRef<"Item", 'String'>
    readonly priority: FieldRef<"Item", 'PriorityType'>
    readonly completed: FieldRef<"Item", 'Boolean'>
    readonly note: FieldRef<"Item", 'String'>
    readonly listId: FieldRef<"Item", 'String'>
    readonly categoryId: FieldRef<"Item", 'String'>
    readonly brand: FieldRef<"Item", 'String'>
    readonly estimatedPrice: FieldRef<"Item", 'Float'>
    readonly addedUserId: FieldRef<"Item", 'String'>
    readonly completedAt: FieldRef<"Item", 'DateTime'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item findRaw
   */
  export type ItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Item aggregateRaw
   */
  export type ItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Item.list
   */
  export type Item$listArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
  }

  /**
   * Item.comments
   */
  export type Item$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    itemId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    itemId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    itemId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    itemId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    itemId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    itemId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    itemId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    itemId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>



  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    itemId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "itemId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      itemId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * @param {CommentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comment = await prisma.comment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CommentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comment.
     * @param {CommentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comment = await prisma.comment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly itemId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment findRaw
   */
  export type CommentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment aggregateRaw
   */
  export type CommentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    userId: string
    code: string
    createdAt: Date
    expiresAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "createdAt" | "expiresAt", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * @param {OtpFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const otp = await prisma.otp.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OtpFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Otp.
     * @param {OtpAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const otp = await prisma.otp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OtpAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly userId: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp findRaw
   */
  export type OtpFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp aggregateRaw
   */
  export type OtpAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    mobile: 'mobile',
    countryCode: 'countryCode',
    isVerified: 'isVerified',
    isActive: 'isActive',
    householdSize: 'householdSize',
    dietaryPreference: 'dietaryPreference',
    shoppingFrequency: 'shoppingFrequency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    refreshTokenHash: 'refreshTokenHash',
    userAgent: 'userAgent',
    platform: 'platform',
    browser: 'browser',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    lastUsed: 'lastUsed',
    revoked: 'revoked'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    deviceId: 'deviceId',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const FamilyGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamilyGroupScalarFieldEnum = (typeof FamilyGroupScalarFieldEnum)[keyof typeof FamilyGroupScalarFieldEnum]


  export const FamilyGroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    joinedAt: 'joinedAt'
  };

  export type FamilyGroupMemberScalarFieldEnum = (typeof FamilyGroupMemberScalarFieldEnum)[keyof typeof FamilyGroupMemberScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    code: 'code',
    invitedBy: 'invitedBy',
    email: 'email',
    role: 'role',
    expiresAt: 'expiresAt',
    used: 'used',
    familyGroupId: 'familyGroupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const ListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdUserId: 'createdUserId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListScalarFieldEnum = (typeof ListScalarFieldEnum)[keyof typeof ListScalarFieldEnum]


  export const ListContributorScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    userId: 'userId'
  };

  export type ListContributorScalarFieldEnum = (typeof ListContributorScalarFieldEnum)[keyof typeof ListContributorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    color: 'color',
    type: 'type',
    isActive: 'isActive',
    createdBy: 'createdBy',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CategorySharedWithScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    userId: 'userId'
  };

  export type CategorySharedWithScalarFieldEnum = (typeof CategorySharedWithScalarFieldEnum)[keyof typeof CategorySharedWithScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    unit: 'unit',
    priority: 'priority',
    completed: 'completed',
    note: 'note',
    listId: 'listId',
    categoryId: 'categoryId',
    brand: 'brand',
    estimatedPrice: 'estimatedPrice',
    addedUserId: 'addedUserId',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    itemId: 'itemId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CategoryType'
   */
  export type EnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType'>
    


  /**
   * Reference to a field of type 'CategoryType[]'
   */
  export type ListEnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PriorityType'
   */
  export type EnumPriorityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityType'>
    


  /**
   * Reference to a field of type 'PriorityType[]'
   */
  export type ListEnumPriorityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    mobile?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    householdSize?: IntFilter<"User"> | number
    dietaryPreference?: StringFilter<"User"> | string
    shoppingFrequency?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    events?: SecurityEventListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    createdGroups?: FamilyGroupListRelationFilter
    memberOfGroups?: FamilyGroupMemberListRelationFilter
    contributedLists?: ListContributorListRelationFilter
    sharedCategories?: CategorySharedWithListRelationFilter
    Otp?: OtpListRelationFilter
    Item?: ItemListRelationFilter
    List?: ListListRelationFilter
    Comment?: CommentListRelationFilter
    createdCategories?: CategoryListRelationFilter
    sentInvites?: InviteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    mobile?: SortOrder
    countryCode?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    householdSize?: SortOrder
    dietaryPreference?: SortOrder
    shoppingFrequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    events?: SecurityEventOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    createdGroups?: FamilyGroupOrderByRelationAggregateInput
    memberOfGroups?: FamilyGroupMemberOrderByRelationAggregateInput
    contributedLists?: ListContributorOrderByRelationAggregateInput
    sharedCategories?: CategorySharedWithOrderByRelationAggregateInput
    Otp?: OtpOrderByRelationAggregateInput
    Item?: ItemOrderByRelationAggregateInput
    List?: ListOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    createdCategories?: CategoryOrderByRelationAggregateInput
    sentInvites?: InviteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    mobile?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    householdSize?: IntFilter<"User"> | number
    dietaryPreference?: StringFilter<"User"> | string
    shoppingFrequency?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    events?: SecurityEventListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    createdGroups?: FamilyGroupListRelationFilter
    memberOfGroups?: FamilyGroupMemberListRelationFilter
    contributedLists?: ListContributorListRelationFilter
    sharedCategories?: CategorySharedWithListRelationFilter
    Otp?: OtpListRelationFilter
    Item?: ItemListRelationFilter
    List?: ListListRelationFilter
    Comment?: CommentListRelationFilter
    createdCategories?: CategoryListRelationFilter
    sentInvites?: InviteListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    mobile?: SortOrder
    countryCode?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    householdSize?: SortOrder
    dietaryPreference?: SortOrder
    shoppingFrequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    mobile?: StringNullableWithAggregatesFilter<"User"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    householdSize?: IntWithAggregatesFilter<"User"> | number
    dietaryPreference?: StringWithAggregatesFilter<"User"> | string
    shoppingFrequency?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    deviceId?: StringFilter<"Session"> | string
    refreshTokenHash?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    platform?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsed?: DateTimeFilter<"Session"> | Date | string
    revoked?: BoolFilter<"Session"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    refreshTokenHash?: SortOrder
    userAgent?: SortOrder
    platform?: SortOrder
    browser?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    revoked?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    deviceId?: StringFilter<"Session"> | string
    refreshTokenHash?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    platform?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsed?: DateTimeFilter<"Session"> | Date | string
    revoked?: BoolFilter<"Session"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    refreshTokenHash?: SortOrder
    userAgent?: SortOrder
    platform?: SortOrder
    browser?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    revoked?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    deviceId?: StringWithAggregatesFilter<"Session"> | string
    refreshTokenHash?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    platform?: StringNullableWithAggregatesFilter<"Session"> | string | null
    browser?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastUsed?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    revoked?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringFilter<"SecurityEvent"> | string
    type?: StringFilter<"SecurityEvent"> | string
    deviceId?: StringNullableFilter<"SecurityEvent"> | string | null
    ip?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    userId?: StringFilter<"SecurityEvent"> | string
    type?: StringFilter<"SecurityEvent"> | string
    deviceId?: StringNullableFilter<"SecurityEvent"> | string | null
    ip?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityEvent"> | string
    userId?: StringWithAggregatesFilter<"SecurityEvent"> | string
    type?: StringWithAggregatesFilter<"SecurityEvent"> | string
    deviceId?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    ip?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    notifications?: XOR<NotificationSettingsCompositeFilter, NotificationSettingsObjectEqualityInput>
    privacy?: XOR<PrivacySettingsCompositeFilter, PrivacySettingsObjectEqualityInput>
    appearance?: XOR<AppearanceSettingsCompositeFilter, AppearanceSettingsObjectEqualityInput>
    accessibility?: XOR<AccessibilitySettingsCompositeFilter, AccessibilitySettingsObjectEqualityInput>
    timezone?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notifications?: NotificationSettingsOrderByInput
    privacy?: PrivacySettingsOrderByInput
    appearance?: AppearanceSettingsOrderByInput
    accessibility?: AccessibilitySettingsOrderByInput
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    notifications?: XOR<NotificationSettingsCompositeFilter, NotificationSettingsObjectEqualityInput>
    privacy?: XOR<PrivacySettingsCompositeFilter, PrivacySettingsObjectEqualityInput>
    appearance?: XOR<AppearanceSettingsCompositeFilter, AppearanceSettingsObjectEqualityInput>
    accessibility?: XOR<AccessibilitySettingsCompositeFilter, AccessibilitySettingsObjectEqualityInput>
    timezone?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    timezone?: StringWithAggregatesFilter<"UserSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type FamilyGroupWhereInput = {
    AND?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    OR?: FamilyGroupWhereInput[]
    NOT?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    id?: StringFilter<"FamilyGroup"> | string
    name?: StringFilter<"FamilyGroup"> | string
    createdBy?: StringFilter<"FamilyGroup"> | string
    createdAt?: DateTimeFilter<"FamilyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: FamilyGroupMemberListRelationFilter
    invites?: InviteListRelationFilter
  }

  export type FamilyGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: FamilyGroupMemberOrderByRelationAggregateInput
    invites?: InviteOrderByRelationAggregateInput
  }

  export type FamilyGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    OR?: FamilyGroupWhereInput[]
    NOT?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    name?: StringFilter<"FamilyGroup"> | string
    createdBy?: StringFilter<"FamilyGroup"> | string
    createdAt?: DateTimeFilter<"FamilyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: FamilyGroupMemberListRelationFilter
    invites?: InviteListRelationFilter
  }, "id">

  export type FamilyGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamilyGroupCountOrderByAggregateInput
    _max?: FamilyGroupMaxOrderByAggregateInput
    _min?: FamilyGroupMinOrderByAggregateInput
  }

  export type FamilyGroupScalarWhereWithAggregatesInput = {
    AND?: FamilyGroupScalarWhereWithAggregatesInput | FamilyGroupScalarWhereWithAggregatesInput[]
    OR?: FamilyGroupScalarWhereWithAggregatesInput[]
    NOT?: FamilyGroupScalarWhereWithAggregatesInput | FamilyGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyGroup"> | string
    name?: StringWithAggregatesFilter<"FamilyGroup"> | string
    createdBy?: StringWithAggregatesFilter<"FamilyGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FamilyGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyGroup"> | Date | string
  }

  export type FamilyGroupMemberWhereInput = {
    AND?: FamilyGroupMemberWhereInput | FamilyGroupMemberWhereInput[]
    OR?: FamilyGroupMemberWhereInput[]
    NOT?: FamilyGroupMemberWhereInput | FamilyGroupMemberWhereInput[]
    id?: StringFilter<"FamilyGroupMember"> | string
    groupId?: StringFilter<"FamilyGroupMember"> | string
    userId?: StringFilter<"FamilyGroupMember"> | string
    joinedAt?: DateTimeFilter<"FamilyGroupMember"> | Date | string
    group?: XOR<FamilyGroupScalarRelationFilter, FamilyGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FamilyGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    group?: FamilyGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FamilyGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: FamilyGroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: FamilyGroupMemberWhereInput | FamilyGroupMemberWhereInput[]
    OR?: FamilyGroupMemberWhereInput[]
    NOT?: FamilyGroupMemberWhereInput | FamilyGroupMemberWhereInput[]
    groupId?: StringFilter<"FamilyGroupMember"> | string
    userId?: StringFilter<"FamilyGroupMember"> | string
    joinedAt?: DateTimeFilter<"FamilyGroupMember"> | Date | string
    group?: XOR<FamilyGroupScalarRelationFilter, FamilyGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type FamilyGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    _count?: FamilyGroupMemberCountOrderByAggregateInput
    _max?: FamilyGroupMemberMaxOrderByAggregateInput
    _min?: FamilyGroupMemberMinOrderByAggregateInput
  }

  export type FamilyGroupMemberScalarWhereWithAggregatesInput = {
    AND?: FamilyGroupMemberScalarWhereWithAggregatesInput | FamilyGroupMemberScalarWhereWithAggregatesInput[]
    OR?: FamilyGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: FamilyGroupMemberScalarWhereWithAggregatesInput | FamilyGroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyGroupMember"> | string
    groupId?: StringWithAggregatesFilter<"FamilyGroupMember"> | string
    userId?: StringWithAggregatesFilter<"FamilyGroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"FamilyGroupMember"> | Date | string
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: StringFilter<"Invite"> | string
    code?: StringFilter<"Invite"> | string
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringFilter<"Invite"> | string
    role?: EnumUserRoleFilter<"Invite"> | $Enums.UserRole
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    used?: BoolFilter<"Invite"> | boolean
    familyGroupId?: StringNullableFilter<"Invite"> | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
    invitedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    familyGroup?: XOR<FamilyGroupNullableScalarRelationFilter, FamilyGroupWhereInput> | null
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    familyGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedByUser?: UserOrderByWithRelationInput
    familyGroup?: FamilyGroupOrderByWithRelationInput
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringFilter<"Invite"> | string
    role?: EnumUserRoleFilter<"Invite"> | $Enums.UserRole
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    used?: BoolFilter<"Invite"> | boolean
    familyGroupId?: StringNullableFilter<"Invite"> | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
    invitedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    familyGroup?: XOR<FamilyGroupNullableScalarRelationFilter, FamilyGroupWhereInput> | null
  }, "id" | "code">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    familyGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InviteCountOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invite"> | string
    code?: StringWithAggregatesFilter<"Invite"> | string
    invitedBy?: StringWithAggregatesFilter<"Invite"> | string
    email?: StringWithAggregatesFilter<"Invite"> | string
    role?: EnumUserRoleWithAggregatesFilter<"Invite"> | $Enums.UserRole
    expiresAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    used?: BoolWithAggregatesFilter<"Invite"> | boolean
    familyGroupId?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
  }

  export type ListWhereInput = {
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    id?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    slug?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    createdUserId?: StringFilter<"List"> | string
    status?: StringFilter<"List"> | string
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    createdUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    contributors?: ListContributorListRelationFilter
    items?: ItemListRelationFilter
  }

  export type ListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdUser?: UserOrderByWithRelationInput
    contributors?: ListContributorOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type ListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    name?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    createdUserId?: StringFilter<"List"> | string
    status?: StringFilter<"List"> | string
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    createdUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    contributors?: ListContributorListRelationFilter
    items?: ItemListRelationFilter
  }, "id" | "slug">

  export type ListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ListCountOrderByAggregateInput
    _max?: ListMaxOrderByAggregateInput
    _min?: ListMinOrderByAggregateInput
  }

  export type ListScalarWhereWithAggregatesInput = {
    AND?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    OR?: ListScalarWhereWithAggregatesInput[]
    NOT?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"List"> | string
    name?: StringWithAggregatesFilter<"List"> | string
    slug?: StringWithAggregatesFilter<"List"> | string
    description?: StringNullableWithAggregatesFilter<"List"> | string | null
    createdUserId?: StringWithAggregatesFilter<"List"> | string
    status?: StringWithAggregatesFilter<"List"> | string
    createdAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
  }

  export type ListContributorWhereInput = {
    AND?: ListContributorWhereInput | ListContributorWhereInput[]
    OR?: ListContributorWhereInput[]
    NOT?: ListContributorWhereInput | ListContributorWhereInput[]
    id?: StringFilter<"ListContributor"> | string
    listId?: StringFilter<"ListContributor"> | string
    userId?: StringFilter<"ListContributor"> | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ListContributorOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrder
    userId?: SortOrder
    list?: ListOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ListContributorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listId_userId?: ListContributorListIdUserIdCompoundUniqueInput
    AND?: ListContributorWhereInput | ListContributorWhereInput[]
    OR?: ListContributorWhereInput[]
    NOT?: ListContributorWhereInput | ListContributorWhereInput[]
    listId?: StringFilter<"ListContributor"> | string
    userId?: StringFilter<"ListContributor"> | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "listId_userId">

  export type ListContributorOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrder
    userId?: SortOrder
    _count?: ListContributorCountOrderByAggregateInput
    _max?: ListContributorMaxOrderByAggregateInput
    _min?: ListContributorMinOrderByAggregateInput
  }

  export type ListContributorScalarWhereWithAggregatesInput = {
    AND?: ListContributorScalarWhereWithAggregatesInput | ListContributorScalarWhereWithAggregatesInput[]
    OR?: ListContributorScalarWhereWithAggregatesInput[]
    NOT?: ListContributorScalarWhereWithAggregatesInput | ListContributorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListContributor"> | string
    listId?: StringWithAggregatesFilter<"ListContributor"> | string
    userId?: StringWithAggregatesFilter<"ListContributor"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    isActive?: BoolFilter<"Category"> | boolean
    createdBy?: StringNullableFilter<"Category"> | string | null
    meta?: JsonNullableFilter<"Category">
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sharedWith?: CategorySharedWithListRelationFilter
    categoryItems?: ItemListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUser?: UserOrderByWithRelationInput
    sharedWith?: CategorySharedWithOrderByRelationAggregateInput
    categoryItems?: ItemOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    isActive?: BoolFilter<"Category"> | boolean
    createdBy?: StringNullableFilter<"Category"> | string | null
    meta?: JsonNullableFilter<"Category">
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sharedWith?: CategorySharedWithListRelationFilter
    categoryItems?: ItemListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    type?: EnumCategoryTypeWithAggregatesFilter<"Category"> | $Enums.CategoryType
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"Category"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"Category">
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type CategorySharedWithWhereInput = {
    AND?: CategorySharedWithWhereInput | CategorySharedWithWhereInput[]
    OR?: CategorySharedWithWhereInput[]
    NOT?: CategorySharedWithWhereInput | CategorySharedWithWhereInput[]
    id?: StringFilter<"CategorySharedWith"> | string
    categoryId?: StringFilter<"CategorySharedWith"> | string
    userId?: StringFilter<"CategorySharedWith"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CategorySharedWithOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CategorySharedWithWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_userId?: CategorySharedWithCategoryIdUserIdCompoundUniqueInput
    AND?: CategorySharedWithWhereInput | CategorySharedWithWhereInput[]
    OR?: CategorySharedWithWhereInput[]
    NOT?: CategorySharedWithWhereInput | CategorySharedWithWhereInput[]
    categoryId?: StringFilter<"CategorySharedWith"> | string
    userId?: StringFilter<"CategorySharedWith"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "categoryId_userId">

  export type CategorySharedWithOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    _count?: CategorySharedWithCountOrderByAggregateInput
    _max?: CategorySharedWithMaxOrderByAggregateInput
    _min?: CategorySharedWithMinOrderByAggregateInput
  }

  export type CategorySharedWithScalarWhereWithAggregatesInput = {
    AND?: CategorySharedWithScalarWhereWithAggregatesInput | CategorySharedWithScalarWhereWithAggregatesInput[]
    OR?: CategorySharedWithScalarWhereWithAggregatesInput[]
    NOT?: CategorySharedWithScalarWhereWithAggregatesInput | CategorySharedWithScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategorySharedWith"> | string
    categoryId?: StringWithAggregatesFilter<"CategorySharedWith"> | string
    userId?: StringWithAggregatesFilter<"CategorySharedWith"> | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    quantity?: IntFilter<"Item"> | number
    unit?: StringNullableFilter<"Item"> | string | null
    priority?: EnumPriorityTypeFilter<"Item"> | $Enums.PriorityType
    completed?: BoolFilter<"Item"> | boolean
    note?: StringNullableFilter<"Item"> | string | null
    listId?: StringNullableFilter<"Item"> | string | null
    categoryId?: StringFilter<"Item"> | string
    brand?: StringNullableFilter<"Item"> | string | null
    estimatedPrice?: FloatFilter<"Item"> | number
    addedUserId?: StringFilter<"Item"> | string
    completedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    list?: XOR<ListNullableScalarRelationFilter, ListWhereInput> | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    note?: SortOrder
    listId?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    estimatedPrice?: SortOrder
    addedUserId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    list?: ListOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    addedBy?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    quantity?: IntFilter<"Item"> | number
    unit?: StringNullableFilter<"Item"> | string | null
    priority?: EnumPriorityTypeFilter<"Item"> | $Enums.PriorityType
    completed?: BoolFilter<"Item"> | boolean
    note?: StringNullableFilter<"Item"> | string | null
    listId?: StringNullableFilter<"Item"> | string | null
    categoryId?: StringFilter<"Item"> | string
    brand?: StringNullableFilter<"Item"> | string | null
    estimatedPrice?: FloatFilter<"Item"> | number
    addedUserId?: StringFilter<"Item"> | string
    completedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    list?: XOR<ListNullableScalarRelationFilter, ListWhereInput> | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    note?: SortOrder
    listId?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    estimatedPrice?: SortOrder
    addedUserId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    quantity?: IntWithAggregatesFilter<"Item"> | number
    unit?: StringNullableWithAggregatesFilter<"Item"> | string | null
    priority?: EnumPriorityTypeWithAggregatesFilter<"Item"> | $Enums.PriorityType
    completed?: BoolWithAggregatesFilter<"Item"> | boolean
    note?: StringNullableWithAggregatesFilter<"Item"> | string | null
    listId?: StringNullableWithAggregatesFilter<"Item"> | string | null
    categoryId?: StringWithAggregatesFilter<"Item"> | string
    brand?: StringNullableWithAggregatesFilter<"Item"> | string | null
    estimatedPrice?: FloatWithAggregatesFilter<"Item"> | number
    addedUserId?: StringWithAggregatesFilter<"Item"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Item"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    itemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    itemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    itemId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    userId?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
  }

  export type SessionUpdateInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SecurityEventCreateInput = {
    id?: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventsInput
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityEventUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
  }

  export type SecurityEventUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateManyInput = {
    id?: string
    userId: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityEventUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    notifications: XOR<NotificationSettingsCreateEnvelopeInput, NotificationSettingsCreateInput>
    privacy: XOR<PrivacySettingsCreateEnvelopeInput, PrivacySettingsCreateInput>
    appearance: XOR<AppearanceSettingsCreateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility: XOR<AccessibilitySettingsCreateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    notifications: XOR<NotificationSettingsCreateEnvelopeInput, NotificationSettingsCreateInput>
    privacy: XOR<PrivacySettingsCreateEnvelopeInput, PrivacySettingsCreateInput>
    appearance: XOR<AppearanceSettingsCreateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility: XOR<AccessibilitySettingsCreateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    notifications: XOR<NotificationSettingsCreateEnvelopeInput, NotificationSettingsCreateInput>
    privacy: XOR<PrivacySettingsCreateEnvelopeInput, PrivacySettingsCreateInput>
    appearance: XOR<AppearanceSettingsCreateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility: XOR<AccessibilitySettingsCreateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: FamilyGroupMemberCreateNestedManyWithoutGroupInput
    invites?: InviteCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupUncheckedCreateInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyGroupMemberUncheckedCreateNestedManyWithoutGroupInput
    invites?: InviteUncheckedCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: FamilyGroupMemberUpdateManyWithoutGroupNestedInput
    invites?: InviteUpdateManyWithoutFamilyGroupNestedInput
  }

  export type FamilyGroupUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    invites?: InviteUncheckedUpdateManyWithoutFamilyGroupNestedInput
  }

  export type FamilyGroupCreateManyInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    group: FamilyGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMemberOfGroupsInput
  }

  export type FamilyGroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
  }

  export type FamilyGroupMemberUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: FamilyGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMemberOfGroupsNestedInput
  }

  export type FamilyGroupMemberUncheckedUpdateInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    joinedAt?: Date | string
  }

  export type FamilyGroupMemberUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberUncheckedUpdateManyInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateInput = {
    id?: string
    code: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedByUser: UserCreateNestedOneWithoutSentInvitesInput
    familyGroup?: FamilyGroupCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateInput = {
    id?: string
    code: string
    invitedBy: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    familyGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedByUser?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
    familyGroup?: FamilyGroupUpdateOneWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    familyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateManyInput = {
    id?: string
    code: string
    invitedBy: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    familyGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    familyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUser: UserCreateNestedOneWithoutListInput
    contributors?: ListContributorCreateNestedManyWithoutListInput
    items?: ItemCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdUserId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: ListContributorUncheckedCreateNestedManyWithoutListInput
    items?: ItemUncheckedCreateNestedManyWithoutListInput
  }

  export type ListUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUser?: UserUpdateOneRequiredWithoutListNestedInput
    contributors?: ListContributorUpdateManyWithoutListNestedInput
    items?: ItemUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: ListContributorUncheckedUpdateManyWithoutListNestedInput
    items?: ItemUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdUserId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListContributorCreateInput = {
    id?: string
    list: ListCreateNestedOneWithoutContributorsInput
    user: UserCreateNestedOneWithoutContributedListsInput
  }

  export type ListContributorUncheckedCreateInput = {
    id?: string
    listId: string
    userId: string
  }

  export type ListContributorUpdateInput = {
    list?: ListUpdateOneRequiredWithoutContributorsNestedInput
    user?: UserUpdateOneRequiredWithoutContributedListsNestedInput
  }

  export type ListContributorUncheckedUpdateInput = {
    listId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ListContributorCreateManyInput = {
    id?: string
    listId: string
    userId: string
  }

  export type ListContributorUpdateManyMutationInput = {

  }

  export type ListContributorUncheckedUpdateManyInput = {
    listId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedCategoriesInput
    sharedWith?: CategorySharedWithCreateNestedManyWithoutCategoryInput
    categoryItems?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    createdBy?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: CategorySharedWithUncheckedCreateNestedManyWithoutCategoryInput
    categoryItems?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedCategoriesNestedInput
    sharedWith?: CategorySharedWithUpdateManyWithoutCategoryNestedInput
    categoryItems?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: CategorySharedWithUncheckedUpdateManyWithoutCategoryNestedInput
    categoryItems?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    createdBy?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategorySharedWithCreateInput = {
    id?: string
    category: CategoryCreateNestedOneWithoutSharedWithInput
    user: UserCreateNestedOneWithoutSharedCategoriesInput
  }

  export type CategorySharedWithUncheckedCreateInput = {
    id?: string
    categoryId: string
    userId: string
  }

  export type CategorySharedWithUpdateInput = {
    category?: CategoryUpdateOneRequiredWithoutSharedWithNestedInput
    user?: UserUpdateOneRequiredWithoutSharedCategoriesNestedInput
  }

  export type CategorySharedWithUncheckedUpdateInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CategorySharedWithCreateManyInput = {
    id?: string
    categoryId: string
    userId: string
  }

  export type CategorySharedWithUpdateManyMutationInput = {

  }

  export type CategorySharedWithUncheckedUpdateManyInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    list?: ListCreateNestedOneWithoutItemsInput
    category: CategoryCreateNestedOneWithoutCategoryItemsInput
    addedBy: UserCreateNestedOneWithoutItemInput
    comments?: CommentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneWithoutItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutCategoryItemsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutItemNestedInput
    comments?: CommentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    itemId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    itemId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutOtpInput
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    userId: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: string
    userId: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SecurityEventListRelationFilter = {
    every?: SecurityEventWhereInput
    some?: SecurityEventWhereInput
    none?: SecurityEventWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type FamilyGroupListRelationFilter = {
    every?: FamilyGroupWhereInput
    some?: FamilyGroupWhereInput
    none?: FamilyGroupWhereInput
  }

  export type FamilyGroupMemberListRelationFilter = {
    every?: FamilyGroupMemberWhereInput
    some?: FamilyGroupMemberWhereInput
    none?: FamilyGroupMemberWhereInput
  }

  export type ListContributorListRelationFilter = {
    every?: ListContributorWhereInput
    some?: ListContributorWhereInput
    none?: ListContributorWhereInput
  }

  export type CategorySharedWithListRelationFilter = {
    every?: CategorySharedWithWhereInput
    some?: CategorySharedWithWhereInput
    none?: CategorySharedWithWhereInput
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ListListRelationFilter = {
    every?: ListWhereInput
    some?: ListWhereInput
    none?: ListWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type InviteListRelationFilter = {
    every?: InviteWhereInput
    some?: InviteWhereInput
    none?: InviteWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListContributorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategorySharedWithOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    mobile?: SortOrder
    countryCode?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    householdSize?: SortOrder
    dietaryPreference?: SortOrder
    shoppingFrequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    householdSize?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    mobile?: SortOrder
    countryCode?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    householdSize?: SortOrder
    dietaryPreference?: SortOrder
    shoppingFrequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    mobile?: SortOrder
    countryCode?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    householdSize?: SortOrder
    dietaryPreference?: SortOrder
    shoppingFrequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    householdSize?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    refreshTokenHash?: SortOrder
    userAgent?: SortOrder
    platform?: SortOrder
    browser?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    revoked?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    refreshTokenHash?: SortOrder
    userAgent?: SortOrder
    platform?: SortOrder
    browser?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    revoked?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    refreshTokenHash?: SortOrder
    userAgent?: SortOrder
    platform?: SortOrder
    browser?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
    revoked?: SortOrder
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsCompositeFilter = {
    equals?: NotificationSettingsObjectEqualityInput
    is?: NotificationSettingsWhereInput
    isNot?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsObjectEqualityInput = {
    email: boolean
    sms: boolean
    push: boolean
    marketing: boolean
    productUpdates: boolean
    securityAlerts: boolean
  }

  export type PrivacySettingsCompositeFilter = {
    equals?: PrivacySettingsObjectEqualityInput
    is?: PrivacySettingsWhereInput
    isNot?: PrivacySettingsWhereInput
  }

  export type PrivacySettingsObjectEqualityInput = {
    profileVisibility: string
    searchVisibility: boolean
    dataSharing: boolean
    adPersonalization: boolean
    twoFactorAuth: boolean
  }

  export type AppearanceSettingsCompositeFilter = {
    equals?: AppearanceSettingsObjectEqualityInput
    is?: AppearanceSettingsWhereInput
    isNot?: AppearanceSettingsWhereInput
  }

  export type AppearanceSettingsObjectEqualityInput = {
    theme: string
    fontSize: string
    compactMode: boolean
    animations: boolean
    highContrastMode: boolean
    colorBlindFriendly: boolean
    language: string
    currency: string
    measuringUnits: string
    dateFormat: string
  }

  export type AccessibilitySettingsCompositeFilter = {
    equals?: AccessibilitySettingsObjectEqualityInput
    is?: AccessibilitySettingsWhereInput
    isNot?: AccessibilitySettingsWhereInput
  }

  export type AccessibilitySettingsObjectEqualityInput = {
    screenReader: boolean
    textToSpeech: boolean
    motionReduction: boolean
  }

  export type NotificationSettingsOrderByInput = {
    email?: SortOrder
    sms?: SortOrder
    push?: SortOrder
    marketing?: SortOrder
    productUpdates?: SortOrder
    securityAlerts?: SortOrder
  }

  export type PrivacySettingsOrderByInput = {
    profileVisibility?: SortOrder
    searchVisibility?: SortOrder
    dataSharing?: SortOrder
    adPersonalization?: SortOrder
    twoFactorAuth?: SortOrder
  }

  export type AppearanceSettingsOrderByInput = {
    theme?: SortOrder
    fontSize?: SortOrder
    compactMode?: SortOrder
    animations?: SortOrder
    highContrastMode?: SortOrder
    colorBlindFriendly?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    measuringUnits?: SortOrder
    dateFormat?: SortOrder
  }

  export type AccessibilitySettingsOrderByInput = {
    screenReader?: SortOrder
    textToSpeech?: SortOrder
    motionReduction?: SortOrder
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyGroupScalarRelationFilter = {
    is?: FamilyGroupWhereInput
    isNot?: FamilyGroupWhereInput
  }

  export type FamilyGroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type FamilyGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type FamilyGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type FamilyGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type FamilyGroupNullableScalarRelationFilter = {
    is?: FamilyGroupWhereInput | null
    isNot?: FamilyGroupWhereInput | null
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    familyGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    familyGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    role?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    familyGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListScalarRelationFilter = {
    is?: ListWhereInput
    isNot?: ListWhereInput
  }

  export type ListContributorListIdUserIdCompoundUniqueInput = {
    listId: string
    userId: string
  }

  export type ListContributorCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    userId?: SortOrder
  }

  export type ListContributorMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    userId?: SortOrder
  }

  export type ListContributorMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    userId?: SortOrder
  }

  export type EnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CategorySharedWithCategoryIdUserIdCompoundUniqueInput = {
    categoryId: string
    userId: string
  }

  export type CategorySharedWithCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
  }

  export type CategorySharedWithMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
  }

  export type CategorySharedWithMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
  }

  export type EnumPriorityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityType | EnumPriorityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityTypeFilter<$PrismaModel> | $Enums.PriorityType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ListNullableScalarRelationFilter = {
    is?: ListWhereInput | null
    isNot?: ListWhereInput | null
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    note?: SortOrder
    listId?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    estimatedPrice?: SortOrder
    addedUserId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    note?: SortOrder
    listId?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    estimatedPrice?: SortOrder
    addedUserId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    note?: SortOrder
    listId?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    estimatedPrice?: SortOrder
    addedUserId?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type EnumPriorityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityType | EnumPriorityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriorityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityTypeFilter<$PrismaModel>
    _max?: NestedEnumPriorityTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    itemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SecurityEventCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type FamilyGroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput> | FamilyGroupCreateWithoutCreatorInput[] | FamilyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutCreatorInput | FamilyGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: FamilyGroupCreateManyCreatorInputEnvelope
    connect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
  }

  export type FamilyGroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput> | FamilyGroupMemberCreateWithoutUserInput[] | FamilyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutUserInput | FamilyGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: FamilyGroupMemberCreateManyUserInputEnvelope
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
  }

  export type ListContributorCreateNestedManyWithoutUserInput = {
    create?: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput> | ListContributorCreateWithoutUserInput[] | ListContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutUserInput | ListContributorCreateOrConnectWithoutUserInput[]
    createMany?: ListContributorCreateManyUserInputEnvelope
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
  }

  export type CategorySharedWithCreateNestedManyWithoutUserInput = {
    create?: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput> | CategorySharedWithCreateWithoutUserInput[] | CategorySharedWithUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutUserInput | CategorySharedWithCreateOrConnectWithoutUserInput[]
    createMany?: CategorySharedWithCreateManyUserInputEnvelope
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
  }

  export type OtpCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutAddedByInput = {
    create?: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput> | ItemCreateWithoutAddedByInput[] | ItemUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutAddedByInput | ItemCreateOrConnectWithoutAddedByInput[]
    createMany?: ItemCreateManyAddedByInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ListCreateNestedManyWithoutCreatedUserInput = {
    create?: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput> | ListCreateWithoutCreatedUserInput[] | ListUncheckedCreateWithoutCreatedUserInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedUserInput | ListCreateOrConnectWithoutCreatedUserInput[]
    createMany?: ListCreateManyCreatedUserInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput> | CategoryCreateWithoutCreatedByUserInput[] | CategoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCreatedByUserInput | CategoryCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: CategoryCreateManyCreatedByUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput> | InviteCreateWithoutInvitedByUserInput[] | InviteUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByUserInput | InviteCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: InviteCreateManyInvitedByUserInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SecurityEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput> | FamilyGroupCreateWithoutCreatorInput[] | FamilyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutCreatorInput | FamilyGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: FamilyGroupCreateManyCreatorInputEnvelope
    connect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
  }

  export type FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput> | FamilyGroupMemberCreateWithoutUserInput[] | FamilyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutUserInput | FamilyGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: FamilyGroupMemberCreateManyUserInputEnvelope
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
  }

  export type ListContributorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput> | ListContributorCreateWithoutUserInput[] | ListContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutUserInput | ListContributorCreateOrConnectWithoutUserInput[]
    createMany?: ListContributorCreateManyUserInputEnvelope
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
  }

  export type CategorySharedWithUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput> | CategorySharedWithCreateWithoutUserInput[] | CategorySharedWithUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutUserInput | CategorySharedWithCreateOrConnectWithoutUserInput[]
    createMany?: CategorySharedWithCreateManyUserInputEnvelope
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
  }

  export type OtpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput> | ItemCreateWithoutAddedByInput[] | ItemUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutAddedByInput | ItemCreateOrConnectWithoutAddedByInput[]
    createMany?: ItemCreateManyAddedByInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutCreatedUserInput = {
    create?: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput> | ListCreateWithoutCreatedUserInput[] | ListUncheckedCreateWithoutCreatedUserInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedUserInput | ListCreateOrConnectWithoutCreatedUserInput[]
    createMany?: ListCreateManyCreatedUserInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput> | CategoryCreateWithoutCreatedByUserInput[] | CategoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCreatedByUserInput | CategoryCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: CategoryCreateManyCreatedByUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput> | InviteCreateWithoutInvitedByUserInput[] | InviteUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByUserInput | InviteCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: InviteCreateManyInvitedByUserInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SecurityEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type FamilyGroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput> | FamilyGroupCreateWithoutCreatorInput[] | FamilyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutCreatorInput | FamilyGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: FamilyGroupUpsertWithWhereUniqueWithoutCreatorInput | FamilyGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FamilyGroupCreateManyCreatorInputEnvelope
    set?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    disconnect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    delete?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    connect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    update?: FamilyGroupUpdateWithWhereUniqueWithoutCreatorInput | FamilyGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FamilyGroupUpdateManyWithWhereWithoutCreatorInput | FamilyGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FamilyGroupScalarWhereInput | FamilyGroupScalarWhereInput[]
  }

  export type FamilyGroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput> | FamilyGroupMemberCreateWithoutUserInput[] | FamilyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutUserInput | FamilyGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: FamilyGroupMemberUpsertWithWhereUniqueWithoutUserInput | FamilyGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamilyGroupMemberCreateManyUserInputEnvelope
    set?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    disconnect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    delete?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    update?: FamilyGroupMemberUpdateWithWhereUniqueWithoutUserInput | FamilyGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamilyGroupMemberUpdateManyWithWhereWithoutUserInput | FamilyGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
  }

  export type ListContributorUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput> | ListContributorCreateWithoutUserInput[] | ListContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutUserInput | ListContributorCreateOrConnectWithoutUserInput[]
    upsert?: ListContributorUpsertWithWhereUniqueWithoutUserInput | ListContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListContributorCreateManyUserInputEnvelope
    set?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    disconnect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    delete?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    update?: ListContributorUpdateWithWhereUniqueWithoutUserInput | ListContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListContributorUpdateManyWithWhereWithoutUserInput | ListContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
  }

  export type CategorySharedWithUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput> | CategorySharedWithCreateWithoutUserInput[] | CategorySharedWithUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutUserInput | CategorySharedWithCreateOrConnectWithoutUserInput[]
    upsert?: CategorySharedWithUpsertWithWhereUniqueWithoutUserInput | CategorySharedWithUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategorySharedWithCreateManyUserInputEnvelope
    set?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    disconnect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    delete?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    update?: CategorySharedWithUpdateWithWhereUniqueWithoutUserInput | CategorySharedWithUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategorySharedWithUpdateManyWithWhereWithoutUserInput | CategorySharedWithUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
  }

  export type OtpUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput> | ItemCreateWithoutAddedByInput[] | ItemUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutAddedByInput | ItemCreateOrConnectWithoutAddedByInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutAddedByInput | ItemUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: ItemCreateManyAddedByInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutAddedByInput | ItemUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutAddedByInput | ItemUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ListUpdateManyWithoutCreatedUserNestedInput = {
    create?: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput> | ListCreateWithoutCreatedUserInput[] | ListUncheckedCreateWithoutCreatedUserInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedUserInput | ListCreateOrConnectWithoutCreatedUserInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutCreatedUserInput | ListUpsertWithWhereUniqueWithoutCreatedUserInput[]
    createMany?: ListCreateManyCreatedUserInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutCreatedUserInput | ListUpdateWithWhereUniqueWithoutCreatedUserInput[]
    updateMany?: ListUpdateManyWithWhereWithoutCreatedUserInput | ListUpdateManyWithWhereWithoutCreatedUserInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput> | CategoryCreateWithoutCreatedByUserInput[] | CategoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCreatedByUserInput | CategoryCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCreatedByUserInput | CategoryUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: CategoryCreateManyCreatedByUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCreatedByUserInput | CategoryUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCreatedByUserInput | CategoryUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput> | InviteCreateWithoutInvitedByUserInput[] | InviteUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByUserInput | InviteCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInvitedByUserInput | InviteUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: InviteCreateManyInvitedByUserInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInvitedByUserInput | InviteUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInvitedByUserInput | InviteUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput> | SecurityEventCreateWithoutUserInput[] | SecurityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SecurityEventCreateOrConnectWithoutUserInput | SecurityEventCreateOrConnectWithoutUserInput[]
    upsert?: SecurityEventUpsertWithWhereUniqueWithoutUserInput | SecurityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SecurityEventCreateManyUserInputEnvelope
    set?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    disconnect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    delete?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    connect?: SecurityEventWhereUniqueInput | SecurityEventWhereUniqueInput[]
    update?: SecurityEventUpdateWithWhereUniqueWithoutUserInput | SecurityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SecurityEventUpdateManyWithWhereWithoutUserInput | SecurityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput> | FamilyGroupCreateWithoutCreatorInput[] | FamilyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutCreatorInput | FamilyGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: FamilyGroupUpsertWithWhereUniqueWithoutCreatorInput | FamilyGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FamilyGroupCreateManyCreatorInputEnvelope
    set?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    disconnect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    delete?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    connect?: FamilyGroupWhereUniqueInput | FamilyGroupWhereUniqueInput[]
    update?: FamilyGroupUpdateWithWhereUniqueWithoutCreatorInput | FamilyGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FamilyGroupUpdateManyWithWhereWithoutCreatorInput | FamilyGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FamilyGroupScalarWhereInput | FamilyGroupScalarWhereInput[]
  }

  export type FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput> | FamilyGroupMemberCreateWithoutUserInput[] | FamilyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutUserInput | FamilyGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: FamilyGroupMemberUpsertWithWhereUniqueWithoutUserInput | FamilyGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamilyGroupMemberCreateManyUserInputEnvelope
    set?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    disconnect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    delete?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    update?: FamilyGroupMemberUpdateWithWhereUniqueWithoutUserInput | FamilyGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamilyGroupMemberUpdateManyWithWhereWithoutUserInput | FamilyGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
  }

  export type ListContributorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput> | ListContributorCreateWithoutUserInput[] | ListContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutUserInput | ListContributorCreateOrConnectWithoutUserInput[]
    upsert?: ListContributorUpsertWithWhereUniqueWithoutUserInput | ListContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListContributorCreateManyUserInputEnvelope
    set?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    disconnect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    delete?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    update?: ListContributorUpdateWithWhereUniqueWithoutUserInput | ListContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListContributorUpdateManyWithWhereWithoutUserInput | ListContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
  }

  export type CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput> | CategorySharedWithCreateWithoutUserInput[] | CategorySharedWithUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutUserInput | CategorySharedWithCreateOrConnectWithoutUserInput[]
    upsert?: CategorySharedWithUpsertWithWhereUniqueWithoutUserInput | CategorySharedWithUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategorySharedWithCreateManyUserInputEnvelope
    set?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    disconnect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    delete?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    update?: CategorySharedWithUpdateWithWhereUniqueWithoutUserInput | CategorySharedWithUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategorySharedWithUpdateManyWithWhereWithoutUserInput | CategorySharedWithUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
  }

  export type OtpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput> | ItemCreateWithoutAddedByInput[] | ItemUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutAddedByInput | ItemCreateOrConnectWithoutAddedByInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutAddedByInput | ItemUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: ItemCreateManyAddedByInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutAddedByInput | ItemUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutAddedByInput | ItemUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutCreatedUserNestedInput = {
    create?: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput> | ListCreateWithoutCreatedUserInput[] | ListUncheckedCreateWithoutCreatedUserInput[]
    connectOrCreate?: ListCreateOrConnectWithoutCreatedUserInput | ListCreateOrConnectWithoutCreatedUserInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutCreatedUserInput | ListUpsertWithWhereUniqueWithoutCreatedUserInput[]
    createMany?: ListCreateManyCreatedUserInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutCreatedUserInput | ListUpdateWithWhereUniqueWithoutCreatedUserInput[]
    updateMany?: ListUpdateManyWithWhereWithoutCreatedUserInput | ListUpdateManyWithWhereWithoutCreatedUserInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput> | CategoryCreateWithoutCreatedByUserInput[] | CategoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCreatedByUserInput | CategoryCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCreatedByUserInput | CategoryUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: CategoryCreateManyCreatedByUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCreatedByUserInput | CategoryUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCreatedByUserInput | CategoryUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput> | InviteCreateWithoutInvitedByUserInput[] | InviteUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByUserInput | InviteCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInvitedByUserInput | InviteUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: InviteCreateManyInvitedByUserInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInvitedByUserInput | InviteUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInvitedByUserInput | InviteUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type NotificationSettingsCreateEnvelopeInput = {
    set?: NotificationSettingsCreateInput
  }

  export type NotificationSettingsCreateInput = {
    email?: boolean
    sms?: boolean
    push?: boolean
    marketing?: boolean
    productUpdates?: boolean
    securityAlerts?: boolean
  }

  export type PrivacySettingsCreateEnvelopeInput = {
    set?: PrivacySettingsCreateInput
  }

  export type PrivacySettingsCreateInput = {
    profileVisibility?: string
    searchVisibility?: boolean
    dataSharing?: boolean
    adPersonalization?: boolean
    twoFactorAuth?: boolean
  }

  export type AppearanceSettingsCreateEnvelopeInput = {
    set?: AppearanceSettingsCreateInput
  }

  export type AppearanceSettingsCreateInput = {
    theme?: string
    fontSize?: string
    compactMode?: boolean
    animations?: boolean
    highContrastMode?: boolean
    colorBlindFriendly?: boolean
    language?: string
    currency?: string
    measuringUnits?: string
    dateFormat?: string
  }

  export type AccessibilitySettingsCreateEnvelopeInput = {
    set?: AccessibilitySettingsCreateInput
  }

  export type AccessibilitySettingsCreateInput = {
    screenReader?: boolean
    textToSpeech?: boolean
    motionReduction?: boolean
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationSettingsUpdateEnvelopeInput = {
    set?: NotificationSettingsCreateInput
    update?: NotificationSettingsUpdateInput
  }

  export type PrivacySettingsUpdateEnvelopeInput = {
    set?: PrivacySettingsCreateInput
    update?: PrivacySettingsUpdateInput
  }

  export type AppearanceSettingsUpdateEnvelopeInput = {
    set?: AppearanceSettingsCreateInput
    update?: AppearanceSettingsUpdateInput
  }

  export type AccessibilitySettingsUpdateEnvelopeInput = {
    set?: AccessibilitySettingsCreateInput
    update?: AccessibilitySettingsUpdateInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutCreatedGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type FamilyGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput> | FamilyGroupMemberCreateWithoutGroupInput[] | FamilyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutGroupInput | FamilyGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: FamilyGroupMemberCreateManyGroupInputEnvelope
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutFamilyGroupInput = {
    create?: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput> | InviteCreateWithoutFamilyGroupInput[] | InviteUncheckedCreateWithoutFamilyGroupInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutFamilyGroupInput | InviteCreateOrConnectWithoutFamilyGroupInput[]
    createMany?: InviteCreateManyFamilyGroupInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type FamilyGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput> | FamilyGroupMemberCreateWithoutGroupInput[] | FamilyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutGroupInput | FamilyGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: FamilyGroupMemberCreateManyGroupInputEnvelope
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutFamilyGroupInput = {
    create?: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput> | InviteCreateWithoutFamilyGroupInput[] | InviteUncheckedCreateWithoutFamilyGroupInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutFamilyGroupInput | InviteCreateOrConnectWithoutFamilyGroupInput[]
    createMany?: InviteCreateManyFamilyGroupInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    upsert?: UserUpsertWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGroupsInput, UserUpdateWithoutCreatedGroupsInput>, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type FamilyGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput> | FamilyGroupMemberCreateWithoutGroupInput[] | FamilyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutGroupInput | FamilyGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: FamilyGroupMemberUpsertWithWhereUniqueWithoutGroupInput | FamilyGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FamilyGroupMemberCreateManyGroupInputEnvelope
    set?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    disconnect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    delete?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    update?: FamilyGroupMemberUpdateWithWhereUniqueWithoutGroupInput | FamilyGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FamilyGroupMemberUpdateManyWithWhereWithoutGroupInput | FamilyGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutFamilyGroupNestedInput = {
    create?: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput> | InviteCreateWithoutFamilyGroupInput[] | InviteUncheckedCreateWithoutFamilyGroupInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutFamilyGroupInput | InviteCreateOrConnectWithoutFamilyGroupInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutFamilyGroupInput | InviteUpsertWithWhereUniqueWithoutFamilyGroupInput[]
    createMany?: InviteCreateManyFamilyGroupInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutFamilyGroupInput | InviteUpdateWithWhereUniqueWithoutFamilyGroupInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutFamilyGroupInput | InviteUpdateManyWithWhereWithoutFamilyGroupInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type FamilyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput> | FamilyGroupMemberCreateWithoutGroupInput[] | FamilyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FamilyGroupMemberCreateOrConnectWithoutGroupInput | FamilyGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: FamilyGroupMemberUpsertWithWhereUniqueWithoutGroupInput | FamilyGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FamilyGroupMemberCreateManyGroupInputEnvelope
    set?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    disconnect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    delete?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    connect?: FamilyGroupMemberWhereUniqueInput | FamilyGroupMemberWhereUniqueInput[]
    update?: FamilyGroupMemberUpdateWithWhereUniqueWithoutGroupInput | FamilyGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FamilyGroupMemberUpdateManyWithWhereWithoutGroupInput | FamilyGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutFamilyGroupNestedInput = {
    create?: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput> | InviteCreateWithoutFamilyGroupInput[] | InviteUncheckedCreateWithoutFamilyGroupInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutFamilyGroupInput | InviteCreateOrConnectWithoutFamilyGroupInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutFamilyGroupInput | InviteUpsertWithWhereUniqueWithoutFamilyGroupInput[]
    createMany?: InviteCreateManyFamilyGroupInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutFamilyGroupInput | InviteUpdateWithWhereUniqueWithoutFamilyGroupInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutFamilyGroupInput | InviteUpdateManyWithWhereWithoutFamilyGroupInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type FamilyGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<FamilyGroupCreateWithoutMembersInput, FamilyGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutMembersInput
    connect?: FamilyGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemberOfGroupsInput = {
    create?: XOR<UserCreateWithoutMemberOfGroupsInput, UserUncheckedCreateWithoutMemberOfGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberOfGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type FamilyGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<FamilyGroupCreateWithoutMembersInput, FamilyGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutMembersInput
    upsert?: FamilyGroupUpsertWithoutMembersInput
    connect?: FamilyGroupWhereUniqueInput
    update?: XOR<XOR<FamilyGroupUpdateToOneWithWhereWithoutMembersInput, FamilyGroupUpdateWithoutMembersInput>, FamilyGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMemberOfGroupsNestedInput = {
    create?: XOR<UserCreateWithoutMemberOfGroupsInput, UserUncheckedCreateWithoutMemberOfGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberOfGroupsInput
    upsert?: UserUpsertWithoutMemberOfGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberOfGroupsInput, UserUpdateWithoutMemberOfGroupsInput>, UserUncheckedUpdateWithoutMemberOfGroupsInput>
  }

  export type UserCreateNestedOneWithoutSentInvitesInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type FamilyGroupCreateNestedOneWithoutInvitesInput = {
    create?: XOR<FamilyGroupCreateWithoutInvitesInput, FamilyGroupUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutInvitesInput
    connect?: FamilyGroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    upsert?: UserUpsertWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitesInput, UserUpdateWithoutSentInvitesInput>, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type FamilyGroupUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<FamilyGroupCreateWithoutInvitesInput, FamilyGroupUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: FamilyGroupCreateOrConnectWithoutInvitesInput
    upsert?: FamilyGroupUpsertWithoutInvitesInput
    disconnect?: boolean
    delete?: FamilyGroupWhereInput | boolean
    connect?: FamilyGroupWhereUniqueInput
    update?: XOR<XOR<FamilyGroupUpdateToOneWithWhereWithoutInvitesInput, FamilyGroupUpdateWithoutInvitesInput>, FamilyGroupUncheckedUpdateWithoutInvitesInput>
  }

  export type UserCreateNestedOneWithoutListInput = {
    create?: XOR<UserCreateWithoutListInput, UserUncheckedCreateWithoutListInput>
    connectOrCreate?: UserCreateOrConnectWithoutListInput
    connect?: UserWhereUniqueInput
  }

  export type ListContributorCreateNestedManyWithoutListInput = {
    create?: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput> | ListContributorCreateWithoutListInput[] | ListContributorUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutListInput | ListContributorCreateOrConnectWithoutListInput[]
    createMany?: ListContributorCreateManyListInputEnvelope
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutListInput = {
    create?: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput> | ItemCreateWithoutListInput[] | ItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutListInput | ItemCreateOrConnectWithoutListInput[]
    createMany?: ItemCreateManyListInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ListContributorUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput> | ListContributorCreateWithoutListInput[] | ListContributorUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutListInput | ListContributorCreateOrConnectWithoutListInput[]
    createMany?: ListContributorCreateManyListInputEnvelope
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput> | ItemCreateWithoutListInput[] | ItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutListInput | ItemCreateOrConnectWithoutListInput[]
    createMany?: ItemCreateManyListInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutListNestedInput = {
    create?: XOR<UserCreateWithoutListInput, UserUncheckedCreateWithoutListInput>
    connectOrCreate?: UserCreateOrConnectWithoutListInput
    upsert?: UserUpsertWithoutListInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListInput, UserUpdateWithoutListInput>, UserUncheckedUpdateWithoutListInput>
  }

  export type ListContributorUpdateManyWithoutListNestedInput = {
    create?: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput> | ListContributorCreateWithoutListInput[] | ListContributorUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutListInput | ListContributorCreateOrConnectWithoutListInput[]
    upsert?: ListContributorUpsertWithWhereUniqueWithoutListInput | ListContributorUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListContributorCreateManyListInputEnvelope
    set?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    disconnect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    delete?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    update?: ListContributorUpdateWithWhereUniqueWithoutListInput | ListContributorUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListContributorUpdateManyWithWhereWithoutListInput | ListContributorUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutListNestedInput = {
    create?: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput> | ItemCreateWithoutListInput[] | ItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutListInput | ItemCreateOrConnectWithoutListInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutListInput | ItemUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ItemCreateManyListInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutListInput | ItemUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutListInput | ItemUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ListContributorUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput> | ListContributorCreateWithoutListInput[] | ListContributorUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListContributorCreateOrConnectWithoutListInput | ListContributorCreateOrConnectWithoutListInput[]
    upsert?: ListContributorUpsertWithWhereUniqueWithoutListInput | ListContributorUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListContributorCreateManyListInputEnvelope
    set?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    disconnect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    delete?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    connect?: ListContributorWhereUniqueInput | ListContributorWhereUniqueInput[]
    update?: ListContributorUpdateWithWhereUniqueWithoutListInput | ListContributorUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListContributorUpdateManyWithWhereWithoutListInput | ListContributorUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput> | ItemCreateWithoutListInput[] | ItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutListInput | ItemCreateOrConnectWithoutListInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutListInput | ItemUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ItemCreateManyListInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutListInput | ItemUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutListInput | ItemUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ListCreateNestedOneWithoutContributorsInput = {
    create?: XOR<ListCreateWithoutContributorsInput, ListUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: ListCreateOrConnectWithoutContributorsInput
    connect?: ListWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContributedListsInput = {
    create?: XOR<UserCreateWithoutContributedListsInput, UserUncheckedCreateWithoutContributedListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributedListsInput
    connect?: UserWhereUniqueInput
  }

  export type ListUpdateOneRequiredWithoutContributorsNestedInput = {
    create?: XOR<ListCreateWithoutContributorsInput, ListUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: ListCreateOrConnectWithoutContributorsInput
    upsert?: ListUpsertWithoutContributorsInput
    connect?: ListWhereUniqueInput
    update?: XOR<XOR<ListUpdateToOneWithWhereWithoutContributorsInput, ListUpdateWithoutContributorsInput>, ListUncheckedUpdateWithoutContributorsInput>
  }

  export type UserUpdateOneRequiredWithoutContributedListsNestedInput = {
    create?: XOR<UserCreateWithoutContributedListsInput, UserUncheckedCreateWithoutContributedListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributedListsInput
    upsert?: UserUpsertWithoutContributedListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContributedListsInput, UserUpdateWithoutContributedListsInput>, UserUncheckedUpdateWithoutContributedListsInput>
  }

  export type UserCreateNestedOneWithoutCreatedCategoriesInput = {
    create?: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CategorySharedWithCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput> | CategorySharedWithCreateWithoutCategoryInput[] | CategorySharedWithUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutCategoryInput | CategorySharedWithCreateOrConnectWithoutCategoryInput[]
    createMany?: CategorySharedWithCreateManyCategoryInputEnvelope
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CategorySharedWithUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput> | CategorySharedWithCreateWithoutCategoryInput[] | CategorySharedWithUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutCategoryInput | CategorySharedWithCreateOrConnectWithoutCategoryInput[]
    createMany?: CategorySharedWithCreateManyCategoryInputEnvelope
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type EnumCategoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.CategoryType
  }

  export type UserUpdateOneWithoutCreatedCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCategoriesInput
    upsert?: UserUpsertWithoutCreatedCategoriesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCategoriesInput, UserUpdateWithoutCreatedCategoriesInput>, UserUncheckedUpdateWithoutCreatedCategoriesInput>
  }

  export type CategorySharedWithUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput> | CategorySharedWithCreateWithoutCategoryInput[] | CategorySharedWithUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutCategoryInput | CategorySharedWithCreateOrConnectWithoutCategoryInput[]
    upsert?: CategorySharedWithUpsertWithWhereUniqueWithoutCategoryInput | CategorySharedWithUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategorySharedWithCreateManyCategoryInputEnvelope
    set?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    disconnect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    delete?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    update?: CategorySharedWithUpdateWithWhereUniqueWithoutCategoryInput | CategorySharedWithUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategorySharedWithUpdateManyWithWhereWithoutCategoryInput | CategorySharedWithUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CategorySharedWithUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput> | CategorySharedWithCreateWithoutCategoryInput[] | CategorySharedWithUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategorySharedWithCreateOrConnectWithoutCategoryInput | CategorySharedWithCreateOrConnectWithoutCategoryInput[]
    upsert?: CategorySharedWithUpsertWithWhereUniqueWithoutCategoryInput | CategorySharedWithUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategorySharedWithCreateManyCategoryInputEnvelope
    set?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    disconnect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    delete?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    connect?: CategorySharedWithWhereUniqueInput | CategorySharedWithWhereUniqueInput[]
    update?: CategorySharedWithUpdateWithWhereUniqueWithoutCategoryInput | CategorySharedWithUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategorySharedWithUpdateManyWithWhereWithoutCategoryInput | CategorySharedWithUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<CategoryCreateWithoutSharedWithInput, CategoryUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSharedWithInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedCategoriesInput = {
    create?: XOR<UserCreateWithoutSharedCategoriesInput, UserUncheckedCreateWithoutSharedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<CategoryCreateWithoutSharedWithInput, CategoryUncheckedCreateWithoutSharedWithInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSharedWithInput
    upsert?: CategoryUpsertWithoutSharedWithInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSharedWithInput, CategoryUpdateWithoutSharedWithInput>, CategoryUncheckedUpdateWithoutSharedWithInput>
  }

  export type UserUpdateOneRequiredWithoutSharedCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutSharedCategoriesInput, UserUncheckedCreateWithoutSharedCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedCategoriesInput
    upsert?: UserUpsertWithoutSharedCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedCategoriesInput, UserUpdateWithoutSharedCategoriesInput>, UserUncheckedUpdateWithoutSharedCategoriesInput>
  }

  export type ListCreateNestedOneWithoutItemsInput = {
    create?: XOR<ListCreateWithoutItemsInput, ListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ListCreateOrConnectWithoutItemsInput
    connect?: ListWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutCategoryItemsInput = {
    create?: XOR<CategoryCreateWithoutCategoryItemsInput, CategoryUncheckedCreateWithoutCategoryItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryItemsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutItemInput = {
    create?: XOR<UserCreateWithoutItemInput, UserUncheckedCreateWithoutItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutItemInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutItemInput = {
    create?: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput> | CommentCreateWithoutItemInput[] | CommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutItemInput | CommentCreateOrConnectWithoutItemInput[]
    createMany?: CommentCreateManyItemInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput> | CommentCreateWithoutItemInput[] | CommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutItemInput | CommentCreateOrConnectWithoutItemInput[]
    createMany?: CommentCreateManyItemInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumPriorityTypeFieldUpdateOperationsInput = {
    set?: $Enums.PriorityType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type ListUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ListCreateWithoutItemsInput, ListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ListCreateOrConnectWithoutItemsInput
    upsert?: ListUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: ListWhereInput | boolean
    connect?: ListWhereUniqueInput
    update?: XOR<XOR<ListUpdateToOneWithWhereWithoutItemsInput, ListUpdateWithoutItemsInput>, ListUncheckedUpdateWithoutItemsInput>
  }

  export type CategoryUpdateOneRequiredWithoutCategoryItemsNestedInput = {
    create?: XOR<CategoryCreateWithoutCategoryItemsInput, CategoryUncheckedCreateWithoutCategoryItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryItemsInput
    upsert?: CategoryUpsertWithoutCategoryItemsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCategoryItemsInput, CategoryUpdateWithoutCategoryItemsInput>, CategoryUncheckedUpdateWithoutCategoryItemsInput>
  }

  export type UserUpdateOneRequiredWithoutItemNestedInput = {
    create?: XOR<UserCreateWithoutItemInput, UserUncheckedCreateWithoutItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutItemInput
    upsert?: UserUpsertWithoutItemInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutItemInput, UserUpdateWithoutItemInput>, UserUncheckedUpdateWithoutItemInput>
  }

  export type CommentUpdateManyWithoutItemNestedInput = {
    create?: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput> | CommentCreateWithoutItemInput[] | CommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutItemInput | CommentCreateOrConnectWithoutItemInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutItemInput | CommentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CommentCreateManyItemInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutItemInput | CommentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutItemInput | CommentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput> | CommentCreateWithoutItemInput[] | CommentUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutItemInput | CommentCreateOrConnectWithoutItemInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutItemInput | CommentUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CommentCreateManyItemInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutItemInput | CommentUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutItemInput | CommentUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ItemCreateWithoutCommentsInput, ItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCommentsInput
    connect?: ItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ItemCreateWithoutCommentsInput, ItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCommentsInput
    upsert?: ItemUpsertWithoutCommentsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCommentsInput, ItemUpdateWithoutCommentsInput>, ItemUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserCreateNestedOneWithoutOtpInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpNestedInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    upsert?: UserUpsertWithoutOtpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpInput, UserUpdateWithoutOtpInput>, UserUncheckedUpdateWithoutOtpInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    email?: BoolFilter<"NotificationSettings"> | boolean
    sms?: BoolFilter<"NotificationSettings"> | boolean
    push?: BoolFilter<"NotificationSettings"> | boolean
    marketing?: BoolFilter<"NotificationSettings"> | boolean
    productUpdates?: BoolFilter<"NotificationSettings"> | boolean
    securityAlerts?: BoolFilter<"NotificationSettings"> | boolean
  }

  export type PrivacySettingsWhereInput = {
    AND?: PrivacySettingsWhereInput | PrivacySettingsWhereInput[]
    OR?: PrivacySettingsWhereInput[]
    NOT?: PrivacySettingsWhereInput | PrivacySettingsWhereInput[]
    profileVisibility?: StringFilter<"PrivacySettings"> | string
    searchVisibility?: BoolFilter<"PrivacySettings"> | boolean
    dataSharing?: BoolFilter<"PrivacySettings"> | boolean
    adPersonalization?: BoolFilter<"PrivacySettings"> | boolean
    twoFactorAuth?: BoolFilter<"PrivacySettings"> | boolean
  }

  export type AppearanceSettingsWhereInput = {
    AND?: AppearanceSettingsWhereInput | AppearanceSettingsWhereInput[]
    OR?: AppearanceSettingsWhereInput[]
    NOT?: AppearanceSettingsWhereInput | AppearanceSettingsWhereInput[]
    theme?: StringFilter<"AppearanceSettings"> | string
    fontSize?: StringFilter<"AppearanceSettings"> | string
    compactMode?: BoolFilter<"AppearanceSettings"> | boolean
    animations?: BoolFilter<"AppearanceSettings"> | boolean
    highContrastMode?: BoolFilter<"AppearanceSettings"> | boolean
    colorBlindFriendly?: BoolFilter<"AppearanceSettings"> | boolean
    language?: StringFilter<"AppearanceSettings"> | string
    currency?: StringFilter<"AppearanceSettings"> | string
    measuringUnits?: StringFilter<"AppearanceSettings"> | string
    dateFormat?: StringFilter<"AppearanceSettings"> | string
  }

  export type AccessibilitySettingsWhereInput = {
    AND?: AccessibilitySettingsWhereInput | AccessibilitySettingsWhereInput[]
    OR?: AccessibilitySettingsWhereInput[]
    NOT?: AccessibilitySettingsWhereInput | AccessibilitySettingsWhereInput[]
    screenReader?: BoolFilter<"AccessibilitySettings"> | boolean
    textToSpeech?: BoolFilter<"AccessibilitySettings"> | boolean
    motionReduction?: BoolFilter<"AccessibilitySettings"> | boolean
  }

  export type NestedEnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }

  export type NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumPriorityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityType | EnumPriorityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityTypeFilter<$PrismaModel> | $Enums.PriorityType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumPriorityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityType | EnumPriorityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityType[] | ListEnumPriorityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriorityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityTypeFilter<$PrismaModel>
    _max?: NestedEnumPriorityTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type SecurityEventCreateWithoutUserInput = {
    id?: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityEventUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityEventCreateOrConnectWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventCreateManyUserInputEnvelope = {
    data: SecurityEventCreateManyUserInput | SecurityEventCreateManyUserInput[]
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    notifications: XOR<NotificationSettingsCreateEnvelopeInput, NotificationSettingsCreateInput>
    privacy: XOR<PrivacySettingsCreateEnvelopeInput, PrivacySettingsCreateInput>
    appearance: XOR<AppearanceSettingsCreateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility: XOR<AccessibilitySettingsCreateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    notifications: XOR<NotificationSettingsCreateEnvelopeInput, NotificationSettingsCreateInput>
    privacy: XOR<PrivacySettingsCreateEnvelopeInput, PrivacySettingsCreateInput>
    appearance: XOR<AppearanceSettingsCreateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility: XOR<AccessibilitySettingsCreateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type FamilyGroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyGroupMemberCreateNestedManyWithoutGroupInput
    invites?: InviteCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyGroupMemberUncheckedCreateNestedManyWithoutGroupInput
    invites?: InviteUncheckedCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupCreateOrConnectWithoutCreatorInput = {
    where: FamilyGroupWhereUniqueInput
    create: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput>
  }

  export type FamilyGroupCreateManyCreatorInputEnvelope = {
    data: FamilyGroupCreateManyCreatorInput | FamilyGroupCreateManyCreatorInput[]
  }

  export type FamilyGroupMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    group: FamilyGroupCreateNestedOneWithoutMembersInput
  }

  export type FamilyGroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
  }

  export type FamilyGroupMemberCreateOrConnectWithoutUserInput = {
    where: FamilyGroupMemberWhereUniqueInput
    create: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type FamilyGroupMemberCreateManyUserInputEnvelope = {
    data: FamilyGroupMemberCreateManyUserInput | FamilyGroupMemberCreateManyUserInput[]
  }

  export type ListContributorCreateWithoutUserInput = {
    id?: string
    list: ListCreateNestedOneWithoutContributorsInput
  }

  export type ListContributorUncheckedCreateWithoutUserInput = {
    id?: string
    listId: string
  }

  export type ListContributorCreateOrConnectWithoutUserInput = {
    where: ListContributorWhereUniqueInput
    create: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput>
  }

  export type ListContributorCreateManyUserInputEnvelope = {
    data: ListContributorCreateManyUserInput | ListContributorCreateManyUserInput[]
  }

  export type CategorySharedWithCreateWithoutUserInput = {
    id?: string
    category: CategoryCreateNestedOneWithoutSharedWithInput
  }

  export type CategorySharedWithUncheckedCreateWithoutUserInput = {
    id?: string
    categoryId: string
  }

  export type CategorySharedWithCreateOrConnectWithoutUserInput = {
    where: CategorySharedWithWhereUniqueInput
    create: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput>
  }

  export type CategorySharedWithCreateManyUserInputEnvelope = {
    data: CategorySharedWithCreateManyUserInput | CategorySharedWithCreateManyUserInput[]
  }

  export type OtpCreateWithoutUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpCreateManyUserInputEnvelope = {
    data: OtpCreateManyUserInput | OtpCreateManyUserInput[]
  }

  export type ItemCreateWithoutAddedByInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    list?: ListCreateNestedOneWithoutItemsInput
    category: CategoryCreateNestedOneWithoutCategoryItemsInput
    comments?: CommentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutAddedByInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutAddedByInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput>
  }

  export type ItemCreateManyAddedByInputEnvelope = {
    data: ItemCreateManyAddedByInput | ItemCreateManyAddedByInput[]
  }

  export type ListCreateWithoutCreatedUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: ListContributorCreateNestedManyWithoutListInput
    items?: ItemCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateWithoutCreatedUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: ListContributorUncheckedCreateNestedManyWithoutListInput
    items?: ItemUncheckedCreateNestedManyWithoutListInput
  }

  export type ListCreateOrConnectWithoutCreatedUserInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput>
  }

  export type ListCreateManyCreatedUserInputEnvelope = {
    data: ListCreateManyCreatedUserInput | ListCreateManyCreatedUserInput[]
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    itemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
  }

  export type CategoryCreateWithoutCreatedByUserInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: CategorySharedWithCreateNestedManyWithoutCategoryInput
    categoryItems?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: CategorySharedWithUncheckedCreateNestedManyWithoutCategoryInput
    categoryItems?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCreatedByUserInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput>
  }

  export type CategoryCreateManyCreatedByUserInputEnvelope = {
    data: CategoryCreateManyCreatedByUserInput | CategoryCreateManyCreatedByUserInput[]
  }

  export type InviteCreateWithoutInvitedByUserInput = {
    id?: string
    code: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    familyGroup?: FamilyGroupCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateWithoutInvitedByUserInput = {
    id?: string
    code: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    familyGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutInvitedByUserInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput>
  }

  export type InviteCreateManyInvitedByUserInputEnvelope = {
    data: InviteCreateManyInvitedByUserInput | InviteCreateManyInvitedByUserInput[]
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    deviceId?: StringFilter<"Session"> | string
    refreshTokenHash?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    platform?: StringNullableFilter<"Session"> | string | null
    browser?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    lastUsed?: DateTimeFilter<"Session"> | Date | string
    revoked?: BoolFilter<"Session"> | boolean
  }

  export type SecurityEventUpsertWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    update: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
    create: XOR<SecurityEventCreateWithoutUserInput, SecurityEventUncheckedCreateWithoutUserInput>
  }

  export type SecurityEventUpdateWithWhereUniqueWithoutUserInput = {
    where: SecurityEventWhereUniqueInput
    data: XOR<SecurityEventUpdateWithoutUserInput, SecurityEventUncheckedUpdateWithoutUserInput>
  }

  export type SecurityEventUpdateManyWithWhereWithoutUserInput = {
    where: SecurityEventScalarWhereInput
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyWithoutUserInput>
  }

  export type SecurityEventScalarWhereInput = {
    AND?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    OR?: SecurityEventScalarWhereInput[]
    NOT?: SecurityEventScalarWhereInput | SecurityEventScalarWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    userId?: StringFilter<"SecurityEvent"> | string
    type?: StringFilter<"SecurityEvent"> | string
    deviceId?: StringNullableFilter<"SecurityEvent"> | string | null
    ip?: StringNullableFilter<"SecurityEvent"> | string | null
    userAgent?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    notifications?: XOR<NotificationSettingsUpdateEnvelopeInput, NotificationSettingsCreateInput>
    privacy?: XOR<PrivacySettingsUpdateEnvelopeInput, PrivacySettingsCreateInput>
    appearance?: XOR<AppearanceSettingsUpdateEnvelopeInput, AppearanceSettingsCreateInput>
    accessibility?: XOR<AccessibilitySettingsUpdateEnvelopeInput, AccessibilitySettingsCreateInput>
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FamilyGroupWhereUniqueInput
    update: XOR<FamilyGroupUpdateWithoutCreatorInput, FamilyGroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<FamilyGroupCreateWithoutCreatorInput, FamilyGroupUncheckedCreateWithoutCreatorInput>
  }

  export type FamilyGroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FamilyGroupWhereUniqueInput
    data: XOR<FamilyGroupUpdateWithoutCreatorInput, FamilyGroupUncheckedUpdateWithoutCreatorInput>
  }

  export type FamilyGroupUpdateManyWithWhereWithoutCreatorInput = {
    where: FamilyGroupScalarWhereInput
    data: XOR<FamilyGroupUpdateManyMutationInput, FamilyGroupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FamilyGroupScalarWhereInput = {
    AND?: FamilyGroupScalarWhereInput | FamilyGroupScalarWhereInput[]
    OR?: FamilyGroupScalarWhereInput[]
    NOT?: FamilyGroupScalarWhereInput | FamilyGroupScalarWhereInput[]
    id?: StringFilter<"FamilyGroup"> | string
    name?: StringFilter<"FamilyGroup"> | string
    createdBy?: StringFilter<"FamilyGroup"> | string
    createdAt?: DateTimeFilter<"FamilyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyGroup"> | Date | string
  }

  export type FamilyGroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: FamilyGroupMemberWhereUniqueInput
    update: XOR<FamilyGroupMemberUpdateWithoutUserInput, FamilyGroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<FamilyGroupMemberCreateWithoutUserInput, FamilyGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type FamilyGroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: FamilyGroupMemberWhereUniqueInput
    data: XOR<FamilyGroupMemberUpdateWithoutUserInput, FamilyGroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type FamilyGroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: FamilyGroupMemberScalarWhereInput
    data: XOR<FamilyGroupMemberUpdateManyMutationInput, FamilyGroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type FamilyGroupMemberScalarWhereInput = {
    AND?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
    OR?: FamilyGroupMemberScalarWhereInput[]
    NOT?: FamilyGroupMemberScalarWhereInput | FamilyGroupMemberScalarWhereInput[]
    id?: StringFilter<"FamilyGroupMember"> | string
    groupId?: StringFilter<"FamilyGroupMember"> | string
    userId?: StringFilter<"FamilyGroupMember"> | string
    joinedAt?: DateTimeFilter<"FamilyGroupMember"> | Date | string
  }

  export type ListContributorUpsertWithWhereUniqueWithoutUserInput = {
    where: ListContributorWhereUniqueInput
    update: XOR<ListContributorUpdateWithoutUserInput, ListContributorUncheckedUpdateWithoutUserInput>
    create: XOR<ListContributorCreateWithoutUserInput, ListContributorUncheckedCreateWithoutUserInput>
  }

  export type ListContributorUpdateWithWhereUniqueWithoutUserInput = {
    where: ListContributorWhereUniqueInput
    data: XOR<ListContributorUpdateWithoutUserInput, ListContributorUncheckedUpdateWithoutUserInput>
  }

  export type ListContributorUpdateManyWithWhereWithoutUserInput = {
    where: ListContributorScalarWhereInput
    data: XOR<ListContributorUpdateManyMutationInput, ListContributorUncheckedUpdateManyWithoutUserInput>
  }

  export type ListContributorScalarWhereInput = {
    AND?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
    OR?: ListContributorScalarWhereInput[]
    NOT?: ListContributorScalarWhereInput | ListContributorScalarWhereInput[]
    id?: StringFilter<"ListContributor"> | string
    listId?: StringFilter<"ListContributor"> | string
    userId?: StringFilter<"ListContributor"> | string
  }

  export type CategorySharedWithUpsertWithWhereUniqueWithoutUserInput = {
    where: CategorySharedWithWhereUniqueInput
    update: XOR<CategorySharedWithUpdateWithoutUserInput, CategorySharedWithUncheckedUpdateWithoutUserInput>
    create: XOR<CategorySharedWithCreateWithoutUserInput, CategorySharedWithUncheckedCreateWithoutUserInput>
  }

  export type CategorySharedWithUpdateWithWhereUniqueWithoutUserInput = {
    where: CategorySharedWithWhereUniqueInput
    data: XOR<CategorySharedWithUpdateWithoutUserInput, CategorySharedWithUncheckedUpdateWithoutUserInput>
  }

  export type CategorySharedWithUpdateManyWithWhereWithoutUserInput = {
    where: CategorySharedWithScalarWhereInput
    data: XOR<CategorySharedWithUpdateManyMutationInput, CategorySharedWithUncheckedUpdateManyWithoutUserInput>
  }

  export type CategorySharedWithScalarWhereInput = {
    AND?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
    OR?: CategorySharedWithScalarWhereInput[]
    NOT?: CategorySharedWithScalarWhereInput | CategorySharedWithScalarWhereInput[]
    id?: StringFilter<"CategorySharedWith"> | string
    categoryId?: StringFilter<"CategorySharedWith"> | string
    userId?: StringFilter<"CategorySharedWith"> | string
  }

  export type OtpUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateManyWithWhereWithoutUserInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpScalarWhereInput = {
    AND?: OtpScalarWhereInput | OtpScalarWhereInput[]
    OR?: OtpScalarWhereInput[]
    NOT?: OtpScalarWhereInput | OtpScalarWhereInput[]
    id?: StringFilter<"Otp"> | string
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type ItemUpsertWithWhereUniqueWithoutAddedByInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutAddedByInput, ItemUncheckedUpdateWithoutAddedByInput>
    create: XOR<ItemCreateWithoutAddedByInput, ItemUncheckedCreateWithoutAddedByInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutAddedByInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutAddedByInput, ItemUncheckedUpdateWithoutAddedByInput>
  }

  export type ItemUpdateManyWithWhereWithoutAddedByInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutAddedByInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    quantity?: IntFilter<"Item"> | number
    unit?: StringNullableFilter<"Item"> | string | null
    priority?: EnumPriorityTypeFilter<"Item"> | $Enums.PriorityType
    completed?: BoolFilter<"Item"> | boolean
    note?: StringNullableFilter<"Item"> | string | null
    listId?: StringNullableFilter<"Item"> | string | null
    categoryId?: StringFilter<"Item"> | string
    brand?: StringNullableFilter<"Item"> | string | null
    estimatedPrice?: FloatFilter<"Item"> | number
    addedUserId?: StringFilter<"Item"> | string
    completedAt?: DateTimeNullableFilter<"Item"> | Date | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
  }

  export type ListUpsertWithWhereUniqueWithoutCreatedUserInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutCreatedUserInput, ListUncheckedUpdateWithoutCreatedUserInput>
    create: XOR<ListCreateWithoutCreatedUserInput, ListUncheckedCreateWithoutCreatedUserInput>
  }

  export type ListUpdateWithWhereUniqueWithoutCreatedUserInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutCreatedUserInput, ListUncheckedUpdateWithoutCreatedUserInput>
  }

  export type ListUpdateManyWithWhereWithoutCreatedUserInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutCreatedUserInput>
  }

  export type ListScalarWhereInput = {
    AND?: ListScalarWhereInput | ListScalarWhereInput[]
    OR?: ListScalarWhereInput[]
    NOT?: ListScalarWhereInput | ListScalarWhereInput[]
    id?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    slug?: StringFilter<"List"> | string
    description?: StringNullableFilter<"List"> | string | null
    createdUserId?: StringFilter<"List"> | string
    status?: StringFilter<"List"> | string
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    itemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCreatedByUserInput, CategoryUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<CategoryCreateWithoutCreatedByUserInput, CategoryUncheckedCreateWithoutCreatedByUserInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCreatedByUserInput, CategoryUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    isActive?: BoolFilter<"Category"> | boolean
    createdBy?: StringNullableFilter<"Category"> | string | null
    meta?: JsonNullableFilter<"Category">
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type InviteUpsertWithWhereUniqueWithoutInvitedByUserInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutInvitedByUserInput, InviteUncheckedUpdateWithoutInvitedByUserInput>
    create: XOR<InviteCreateWithoutInvitedByUserInput, InviteUncheckedCreateWithoutInvitedByUserInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutInvitedByUserInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutInvitedByUserInput, InviteUncheckedUpdateWithoutInvitedByUserInput>
  }

  export type InviteUpdateManyWithWhereWithoutInvitedByUserInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutInvitedByUserInput>
  }

  export type InviteScalarWhereInput = {
    AND?: InviteScalarWhereInput | InviteScalarWhereInput[]
    OR?: InviteScalarWhereInput[]
    NOT?: InviteScalarWhereInput | InviteScalarWhereInput[]
    id?: StringFilter<"Invite"> | string
    code?: StringFilter<"Invite"> | string
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringFilter<"Invite"> | string
    role?: EnumUserRoleFilter<"Invite"> | $Enums.UserRole
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    used?: BoolFilter<"Invite"> | boolean
    familyGroupId?: StringNullableFilter<"Invite"> | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type NotificationSettingsUpdateInput = {
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    marketing?: BoolFieldUpdateOperationsInput | boolean
    productUpdates?: BoolFieldUpdateOperationsInput | boolean
    securityAlerts?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrivacySettingsUpdateInput = {
    profileVisibility?: StringFieldUpdateOperationsInput | string
    searchVisibility?: BoolFieldUpdateOperationsInput | boolean
    dataSharing?: BoolFieldUpdateOperationsInput | boolean
    adPersonalization?: BoolFieldUpdateOperationsInput | boolean
    twoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppearanceSettingsUpdateInput = {
    theme?: StringFieldUpdateOperationsInput | string
    fontSize?: StringFieldUpdateOperationsInput | string
    compactMode?: BoolFieldUpdateOperationsInput | boolean
    animations?: BoolFieldUpdateOperationsInput | boolean
    highContrastMode?: BoolFieldUpdateOperationsInput | boolean
    colorBlindFriendly?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    measuringUnits?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
  }

  export type AccessibilitySettingsUpdateInput = {
    screenReader?: BoolFieldUpdateOperationsInput | boolean
    textToSpeech?: BoolFieldUpdateOperationsInput | boolean
    motionReduction?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutCreatedGroupsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
  }

  export type FamilyGroupMemberCreateWithoutGroupInput = {
    id?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMemberOfGroupsInput
  }

  export type FamilyGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type FamilyGroupMemberCreateOrConnectWithoutGroupInput = {
    where: FamilyGroupMemberWhereUniqueInput
    create: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type FamilyGroupMemberCreateManyGroupInputEnvelope = {
    data: FamilyGroupMemberCreateManyGroupInput | FamilyGroupMemberCreateManyGroupInput[]
  }

  export type InviteCreateWithoutFamilyGroupInput = {
    id?: string
    code: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedByUser: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type InviteUncheckedCreateWithoutFamilyGroupInput = {
    id?: string
    code: string
    invitedBy: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutFamilyGroupInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput>
  }

  export type InviteCreateManyFamilyGroupInputEnvelope = {
    data: InviteCreateManyFamilyGroupInput | InviteCreateManyFamilyGroupInput[]
  }

  export type UserUpsertWithoutCreatedGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type UserUpdateWithoutCreatedGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type FamilyGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: FamilyGroupMemberWhereUniqueInput
    update: XOR<FamilyGroupMemberUpdateWithoutGroupInput, FamilyGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<FamilyGroupMemberCreateWithoutGroupInput, FamilyGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type FamilyGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: FamilyGroupMemberWhereUniqueInput
    data: XOR<FamilyGroupMemberUpdateWithoutGroupInput, FamilyGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type FamilyGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: FamilyGroupMemberScalarWhereInput
    data: XOR<FamilyGroupMemberUpdateManyMutationInput, FamilyGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type InviteUpsertWithWhereUniqueWithoutFamilyGroupInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutFamilyGroupInput, InviteUncheckedUpdateWithoutFamilyGroupInput>
    create: XOR<InviteCreateWithoutFamilyGroupInput, InviteUncheckedCreateWithoutFamilyGroupInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutFamilyGroupInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutFamilyGroupInput, InviteUncheckedUpdateWithoutFamilyGroupInput>
  }

  export type InviteUpdateManyWithWhereWithoutFamilyGroupInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutFamilyGroupInput>
  }

  export type FamilyGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    invites?: InviteCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: InviteUncheckedCreateNestedManyWithoutFamilyGroupInput
  }

  export type FamilyGroupCreateOrConnectWithoutMembersInput = {
    where: FamilyGroupWhereUniqueInput
    create: XOR<FamilyGroupCreateWithoutMembersInput, FamilyGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMemberOfGroupsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutMemberOfGroupsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutMemberOfGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberOfGroupsInput, UserUncheckedCreateWithoutMemberOfGroupsInput>
  }

  export type FamilyGroupUpsertWithoutMembersInput = {
    update: XOR<FamilyGroupUpdateWithoutMembersInput, FamilyGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<FamilyGroupCreateWithoutMembersInput, FamilyGroupUncheckedCreateWithoutMembersInput>
    where?: FamilyGroupWhereInput
  }

  export type FamilyGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: FamilyGroupWhereInput
    data: XOR<FamilyGroupUpdateWithoutMembersInput, FamilyGroupUncheckedUpdateWithoutMembersInput>
  }

  export type FamilyGroupUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    invites?: InviteUpdateManyWithoutFamilyGroupNestedInput
  }

  export type FamilyGroupUncheckedUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: InviteUncheckedUpdateManyWithoutFamilyGroupNestedInput
  }

  export type UserUpsertWithoutMemberOfGroupsInput = {
    update: XOR<UserUpdateWithoutMemberOfGroupsInput, UserUncheckedUpdateWithoutMemberOfGroupsInput>
    create: XOR<UserCreateWithoutMemberOfGroupsInput, UserUncheckedCreateWithoutMemberOfGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberOfGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberOfGroupsInput, UserUncheckedUpdateWithoutMemberOfGroupsInput>
  }

  export type UserUpdateWithoutMemberOfGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberOfGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutSentInvitesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutSentInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
  }

  export type FamilyGroupCreateWithoutInvitesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    members?: FamilyGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type FamilyGroupUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FamilyGroupCreateOrConnectWithoutInvitesInput = {
    where: FamilyGroupWhereUniqueInput
    create: XOR<FamilyGroupCreateWithoutInvitesInput, FamilyGroupUncheckedCreateWithoutInvitesInput>
  }

  export type UserUpsertWithoutSentInvitesInput = {
    update: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type UserUpdateWithoutSentInvitesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type FamilyGroupUpsertWithoutInvitesInput = {
    update: XOR<FamilyGroupUpdateWithoutInvitesInput, FamilyGroupUncheckedUpdateWithoutInvitesInput>
    create: XOR<FamilyGroupCreateWithoutInvitesInput, FamilyGroupUncheckedCreateWithoutInvitesInput>
    where?: FamilyGroupWhereInput
  }

  export type FamilyGroupUpdateToOneWithWhereWithoutInvitesInput = {
    where?: FamilyGroupWhereInput
    data: XOR<FamilyGroupUpdateWithoutInvitesInput, FamilyGroupUncheckedUpdateWithoutInvitesInput>
  }

  export type FamilyGroupUpdateWithoutInvitesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    members?: FamilyGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type FamilyGroupUncheckedUpdateWithoutInvitesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserCreateWithoutListInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutListInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutListInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListInput, UserUncheckedCreateWithoutListInput>
  }

  export type ListContributorCreateWithoutListInput = {
    id?: string
    user: UserCreateNestedOneWithoutContributedListsInput
  }

  export type ListContributorUncheckedCreateWithoutListInput = {
    id?: string
    userId: string
  }

  export type ListContributorCreateOrConnectWithoutListInput = {
    where: ListContributorWhereUniqueInput
    create: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput>
  }

  export type ListContributorCreateManyListInputEnvelope = {
    data: ListContributorCreateManyListInput | ListContributorCreateManyListInput[]
  }

  export type ItemCreateWithoutListInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutCategoryItemsInput
    addedBy: UserCreateNestedOneWithoutItemInput
    comments?: CommentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutListInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutListInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput>
  }

  export type ItemCreateManyListInputEnvelope = {
    data: ItemCreateManyListInput | ItemCreateManyListInput[]
  }

  export type UserUpsertWithoutListInput = {
    update: XOR<UserUpdateWithoutListInput, UserUncheckedUpdateWithoutListInput>
    create: XOR<UserCreateWithoutListInput, UserUncheckedCreateWithoutListInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListInput, UserUncheckedUpdateWithoutListInput>
  }

  export type UserUpdateWithoutListInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type ListContributorUpsertWithWhereUniqueWithoutListInput = {
    where: ListContributorWhereUniqueInput
    update: XOR<ListContributorUpdateWithoutListInput, ListContributorUncheckedUpdateWithoutListInput>
    create: XOR<ListContributorCreateWithoutListInput, ListContributorUncheckedCreateWithoutListInput>
  }

  export type ListContributorUpdateWithWhereUniqueWithoutListInput = {
    where: ListContributorWhereUniqueInput
    data: XOR<ListContributorUpdateWithoutListInput, ListContributorUncheckedUpdateWithoutListInput>
  }

  export type ListContributorUpdateManyWithWhereWithoutListInput = {
    where: ListContributorScalarWhereInput
    data: XOR<ListContributorUpdateManyMutationInput, ListContributorUncheckedUpdateManyWithoutListInput>
  }

  export type ItemUpsertWithWhereUniqueWithoutListInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutListInput, ItemUncheckedUpdateWithoutListInput>
    create: XOR<ItemCreateWithoutListInput, ItemUncheckedCreateWithoutListInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutListInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutListInput, ItemUncheckedUpdateWithoutListInput>
  }

  export type ItemUpdateManyWithWhereWithoutListInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutListInput>
  }

  export type ListCreateWithoutContributorsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUser: UserCreateNestedOneWithoutListInput
    items?: ItemCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateWithoutContributorsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdUserId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutListInput
  }

  export type ListCreateOrConnectWithoutContributorsInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutContributorsInput, ListUncheckedCreateWithoutContributorsInput>
  }

  export type UserCreateWithoutContributedListsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutContributedListsInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutContributedListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContributedListsInput, UserUncheckedCreateWithoutContributedListsInput>
  }

  export type ListUpsertWithoutContributorsInput = {
    update: XOR<ListUpdateWithoutContributorsInput, ListUncheckedUpdateWithoutContributorsInput>
    create: XOR<ListCreateWithoutContributorsInput, ListUncheckedCreateWithoutContributorsInput>
    where?: ListWhereInput
  }

  export type ListUpdateToOneWithWhereWithoutContributorsInput = {
    where?: ListWhereInput
    data: XOR<ListUpdateWithoutContributorsInput, ListUncheckedUpdateWithoutContributorsInput>
  }

  export type ListUpdateWithoutContributorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUser?: UserUpdateOneRequiredWithoutListNestedInput
    items?: ItemUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateWithoutContributorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutListNestedInput
  }

  export type UserUpsertWithoutContributedListsInput = {
    update: XOR<UserUpdateWithoutContributedListsInput, UserUncheckedUpdateWithoutContributedListsInput>
    create: XOR<UserCreateWithoutContributedListsInput, UserUncheckedCreateWithoutContributedListsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContributedListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContributedListsInput, UserUncheckedUpdateWithoutContributedListsInput>
  }

  export type UserUpdateWithoutContributedListsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContributedListsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutCreatedCategoriesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCategoriesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
  }

  export type CategorySharedWithCreateWithoutCategoryInput = {
    id?: string
    user: UserCreateNestedOneWithoutSharedCategoriesInput
  }

  export type CategorySharedWithUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
  }

  export type CategorySharedWithCreateOrConnectWithoutCategoryInput = {
    where: CategorySharedWithWhereUniqueInput
    create: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput>
  }

  export type CategorySharedWithCreateManyCategoryInputEnvelope = {
    data: CategorySharedWithCreateManyCategoryInput | CategorySharedWithCreateManyCategoryInput[]
  }

  export type ItemCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    list?: ListCreateNestedOneWithoutItemsInput
    addedBy: UserCreateNestedOneWithoutItemInput
    comments?: CommentCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: ItemCreateManyCategoryInput | ItemCreateManyCategoryInput[]
  }

  export type UserUpsertWithoutCreatedCategoriesInput = {
    update: XOR<UserUpdateWithoutCreatedCategoriesInput, UserUncheckedUpdateWithoutCreatedCategoriesInput>
    create: XOR<UserCreateWithoutCreatedCategoriesInput, UserUncheckedCreateWithoutCreatedCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCategoriesInput, UserUncheckedUpdateWithoutCreatedCategoriesInput>
  }

  export type UserUpdateWithoutCreatedCategoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCategoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type CategorySharedWithUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategorySharedWithWhereUniqueInput
    update: XOR<CategorySharedWithUpdateWithoutCategoryInput, CategorySharedWithUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategorySharedWithCreateWithoutCategoryInput, CategorySharedWithUncheckedCreateWithoutCategoryInput>
  }

  export type CategorySharedWithUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategorySharedWithWhereUniqueInput
    data: XOR<CategorySharedWithUpdateWithoutCategoryInput, CategorySharedWithUncheckedUpdateWithoutCategoryInput>
  }

  export type CategorySharedWithUpdateManyWithWhereWithoutCategoryInput = {
    where: CategorySharedWithScalarWhereInput
    data: XOR<CategorySharedWithUpdateManyMutationInput, CategorySharedWithUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutSharedWithInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedCategoriesInput
    categoryItems?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSharedWithInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    createdBy?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryItems?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSharedWithInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSharedWithInput, CategoryUncheckedCreateWithoutSharedWithInput>
  }

  export type UserCreateWithoutSharedCategoriesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutSharedCategoriesInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutSharedCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedCategoriesInput, UserUncheckedCreateWithoutSharedCategoriesInput>
  }

  export type CategoryUpsertWithoutSharedWithInput = {
    update: XOR<CategoryUpdateWithoutSharedWithInput, CategoryUncheckedUpdateWithoutSharedWithInput>
    create: XOR<CategoryCreateWithoutSharedWithInput, CategoryUncheckedCreateWithoutSharedWithInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSharedWithInput, CategoryUncheckedUpdateWithoutSharedWithInput>
  }

  export type CategoryUpdateWithoutSharedWithInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedCategoriesNestedInput
    categoryItems?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSharedWithInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryItems?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutSharedCategoriesInput = {
    update: XOR<UserUpdateWithoutSharedCategoriesInput, UserUncheckedUpdateWithoutSharedCategoriesInput>
    create: XOR<UserCreateWithoutSharedCategoriesInput, UserUncheckedCreateWithoutSharedCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedCategoriesInput, UserUncheckedUpdateWithoutSharedCategoriesInput>
  }

  export type UserUpdateWithoutSharedCategoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedCategoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type ListCreateWithoutItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdUser: UserCreateNestedOneWithoutListInput
    contributors?: ListContributorCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdUserId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: ListContributorUncheckedCreateNestedManyWithoutListInput
  }

  export type ListCreateOrConnectWithoutItemsInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutItemsInput, ListUncheckedCreateWithoutItemsInput>
  }

  export type CategoryCreateWithoutCategoryItemsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedCategoriesInput
    sharedWith?: CategorySharedWithCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCategoryItemsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    createdBy?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedWith?: CategorySharedWithUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCategoryItemsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCategoryItemsInput, CategoryUncheckedCreateWithoutCategoryItemsInput>
  }

  export type UserCreateWithoutItemInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutItemInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutItemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutItemInput, UserUncheckedCreateWithoutItemInput>
  }

  export type CommentCreateWithoutItemInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutItemInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutItemInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput>
  }

  export type CommentCreateManyItemInputEnvelope = {
    data: CommentCreateManyItemInput | CommentCreateManyItemInput[]
  }

  export type ListUpsertWithoutItemsInput = {
    update: XOR<ListUpdateWithoutItemsInput, ListUncheckedUpdateWithoutItemsInput>
    create: XOR<ListCreateWithoutItemsInput, ListUncheckedCreateWithoutItemsInput>
    where?: ListWhereInput
  }

  export type ListUpdateToOneWithWhereWithoutItemsInput = {
    where?: ListWhereInput
    data: XOR<ListUpdateWithoutItemsInput, ListUncheckedUpdateWithoutItemsInput>
  }

  export type ListUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdUser?: UserUpdateOneRequiredWithoutListNestedInput
    contributors?: ListContributorUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: ListContributorUncheckedUpdateManyWithoutListNestedInput
  }

  export type CategoryUpsertWithoutCategoryItemsInput = {
    update: XOR<CategoryUpdateWithoutCategoryItemsInput, CategoryUncheckedUpdateWithoutCategoryItemsInput>
    create: XOR<CategoryCreateWithoutCategoryItemsInput, CategoryUncheckedCreateWithoutCategoryItemsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCategoryItemsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCategoryItemsInput, CategoryUncheckedUpdateWithoutCategoryItemsInput>
  }

  export type CategoryUpdateWithoutCategoryItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedCategoriesNestedInput
    sharedWith?: CategorySharedWithUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCategoryItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: CategorySharedWithUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutItemInput = {
    update: XOR<UserUpdateWithoutItemInput, UserUncheckedUpdateWithoutItemInput>
    create: XOR<UserCreateWithoutItemInput, UserUncheckedCreateWithoutItemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutItemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutItemInput, UserUncheckedUpdateWithoutItemInput>
  }

  export type UserUpdateWithoutItemInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutItemInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutItemInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutItemInput, CommentUncheckedUpdateWithoutItemInput>
    create: XOR<CommentCreateWithoutItemInput, CommentUncheckedCreateWithoutItemInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutItemInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutItemInput, CommentUncheckedUpdateWithoutItemInput>
  }

  export type CommentUpdateManyWithWhereWithoutItemInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    list?: ListCreateNestedOneWithoutItemsInput
    category: CategoryCreateNestedOneWithoutCategoryItemsInput
    addedBy: UserCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutCommentsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCommentsInput, ItemUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type ItemUpsertWithoutCommentsInput = {
    update: XOR<ItemUpdateWithoutCommentsInput, ItemUncheckedUpdateWithoutCommentsInput>
    create: XOR<ItemCreateWithoutCommentsInput, ItemUncheckedCreateWithoutCommentsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCommentsInput, ItemUncheckedUpdateWithoutCommentsInput>
  }

  export type ItemUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneWithoutItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutCategoryItemsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserCreateWithoutOtpInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: SecurityEventCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithCreateNestedManyWithoutUserInput
    Item?: ItemCreateNestedManyWithoutAddedByInput
    List?: ListCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    createdCategories?: CategoryCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserUncheckedCreateWithoutOtpInput = {
    id?: string
    username: string
    email: string
    name?: string | null
    password: string
    role?: $Enums.UserRole
    mobile?: string | null
    countryCode?: string | null
    isVerified?: boolean
    isActive?: boolean
    householdSize?: number
    dietaryPreference?: string
    shoppingFrequency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: SecurityEventUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    createdGroups?: FamilyGroupUncheckedCreateNestedManyWithoutCreatorInput
    memberOfGroups?: FamilyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    contributedLists?: ListContributorUncheckedCreateNestedManyWithoutUserInput
    sharedCategories?: CategorySharedWithUncheckedCreateNestedManyWithoutUserInput
    Item?: ItemUncheckedCreateNestedManyWithoutAddedByInput
    List?: ListUncheckedCreateNestedManyWithoutCreatedUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdCategories?: CategoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutInvitedByUserInput
  }

  export type UserCreateOrConnectWithoutOtpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpsertWithoutOtpInput = {
    update: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
  }

  export type UserUpdateWithoutOtpInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: SecurityEventUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUpdateManyWithoutUserNestedInput
    Item?: ItemUpdateManyWithoutAddedByNestedInput
    List?: ListUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUpdateManyWithoutInvitedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    householdSize?: IntFieldUpdateOperationsInput | number
    dietaryPreference?: StringFieldUpdateOperationsInput | string
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: SecurityEventUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    createdGroups?: FamilyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    memberOfGroups?: FamilyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    contributedLists?: ListContributorUncheckedUpdateManyWithoutUserNestedInput
    sharedCategories?: CategorySharedWithUncheckedUpdateManyWithoutUserNestedInput
    Item?: ItemUncheckedUpdateManyWithoutAddedByNestedInput
    List?: ListUncheckedUpdateManyWithoutCreatedUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdCategories?: CategoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutInvitedByUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    deviceId: string
    refreshTokenHash: string
    userAgent?: string | null
    platform?: string | null
    browser?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    lastUsed?: Date | string
    revoked?: boolean
  }

  export type SecurityEventCreateManyUserInput = {
    id?: string
    type: string
    deviceId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyGroupCreateManyCreatorInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyGroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    joinedAt?: Date | string
  }

  export type ListContributorCreateManyUserInput = {
    id?: string
    listId: string
  }

  export type CategorySharedWithCreateManyUserInput = {
    id?: string
    categoryId: string
  }

  export type OtpCreateManyUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type ItemCreateManyAddedByInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListCreateManyCreatedUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    content: string
    itemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyCreatedByUserInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type?: $Enums.CategoryType
    isActive?: boolean
    meta?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateManyInvitedByUserInput = {
    id?: string
    code: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    familyGroupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SecurityEventUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyGroupMemberUpdateManyWithoutGroupNestedInput
    invites?: InviteUpdateManyWithoutFamilyGroupNestedInput
  }

  export type FamilyGroupUncheckedUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    invites?: InviteUncheckedUpdateManyWithoutFamilyGroupNestedInput
  }

  export type FamilyGroupUncheckedUpdateManyWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: FamilyGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type FamilyGroupMemberUncheckedUpdateWithoutUserInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberUncheckedUpdateManyWithoutUserInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListContributorUpdateWithoutUserInput = {
    list?: ListUpdateOneRequiredWithoutContributorsNestedInput
  }

  export type ListContributorUncheckedUpdateWithoutUserInput = {
    listId?: StringFieldUpdateOperationsInput | string
  }

  export type ListContributorUncheckedUpdateManyWithoutUserInput = {
    listId?: StringFieldUpdateOperationsInput | string
  }

  export type CategorySharedWithUpdateWithoutUserInput = {
    category?: CategoryUpdateOneRequiredWithoutSharedWithNestedInput
  }

  export type CategorySharedWithUncheckedUpdateWithoutUserInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CategorySharedWithUncheckedUpdateManyWithoutUserInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type OtpUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutAddedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneWithoutItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutCategoryItemsNestedInput
    comments?: CommentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutAddedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutAddedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUpdateWithoutCreatedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: ListContributorUpdateManyWithoutListNestedInput
    items?: ItemUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateWithoutCreatedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: ListContributorUncheckedUpdateManyWithoutListNestedInput
    items?: ItemUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateManyWithoutCreatedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutCreatedByUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: CategorySharedWithUpdateManyWithoutCategoryNestedInput
    categoryItems?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCreatedByUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedWith?: CategorySharedWithUncheckedUpdateManyWithoutCategoryNestedInput
    categoryItems?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCreatedByUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutInvitedByUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyGroup?: FamilyGroupUpdateOneWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutInvitedByUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    familyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyWithoutInvitedByUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    familyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type InviteCreateManyFamilyGroupInput = {
    id?: string
    code: string
    invitedBy: string
    email: string
    role?: $Enums.UserRole
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyGroupMemberUpdateWithoutGroupInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMemberOfGroupsNestedInput
  }

  export type FamilyGroupMemberUncheckedUpdateWithoutGroupInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutFamilyGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedByUser?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutFamilyGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyWithoutFamilyGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListContributorCreateManyListInput = {
    id?: string
    userId: string
  }

  export type ItemCreateManyListInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    categoryId: string
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListContributorUpdateWithoutListInput = {
    user?: UserUpdateOneRequiredWithoutContributedListsNestedInput
  }

  export type ListContributorUncheckedUpdateWithoutListInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ListContributorUncheckedUpdateManyWithoutListInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUpdateWithoutListInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutCategoryItemsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutItemNestedInput
    comments?: CommentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutListInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutListInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategorySharedWithCreateManyCategoryInput = {
    id?: string
    userId: string
  }

  export type ItemCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    unit?: string | null
    priority?: $Enums.PriorityType
    completed?: boolean
    note?: string | null
    listId?: string | null
    brand?: string | null
    estimatedPrice: number
    addedUserId: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategorySharedWithUpdateWithoutCategoryInput = {
    user?: UserUpdateOneRequiredWithoutSharedCategoriesNestedInput
  }

  export type CategorySharedWithUncheckedUpdateWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CategorySharedWithUncheckedUpdateManyWithoutCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneWithoutItemsNestedInput
    addedBy?: UserUpdateOneRequiredWithoutItemNestedInput
    comments?: CommentUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityTypeFieldUpdateOperationsInput | $Enums.PriorityType
    completed?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: FloatFieldUpdateOperationsInput | number
    addedUserId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyItemInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutItemInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutItemInput = {
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutItemInput = {
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}